<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>nanimonai&#39;s Blog</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on nanimonai&#39;s Blog</description>
    <generator>Hugo -- 0.138.0</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 17 Nov 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rescue of a Faulty Monitor</title>
      <link>http://localhost:1313/posts/tech/rescue-of-a-faulty-monitor/</link>
      <pubDate>Sun, 17 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/tech/rescue-of-a-faulty-monitor/</guid>
      <description>低品質のブログ</description>
      <content:encoded><![CDATA[<h1 id="失灵显示器拯救记"><strong>失灵显示器拯救记</strong></h1>
<p>​本人在10月份换成了MATX，电脑也从N系笔记本来到了AMD的6750GRE</p>
<p>入手一2.5k16寸显示器。本来想自制的，后面听朋友说非常麻烦且容易踩坑，DIY花销不一定比自己小，于是直接购入别人已经做好的所谓A-屏。在我这台的情况是所谓A-屏就是有一个0.1mm不到的色块不显示，个人认为还能接受并且价格也还挺美丽</p>
<p>​然后问题就来了，小作坊用料就是怪，即这个显示器跑不到预想的分辨率和刷新率。在Windows系统上我的解决办法是使用AMD Software生成一份配置文件，其中他会写一个对于刷新率的感叹号但是你不用去管它。来到Arch我就有些头疼了，他直接给我画面干撕裂了，然后设置界面是经典的“仅支持 640x350”，遂尝试</p>
<h2 id="失败的尝试">失败的尝试：</h2>
<p>GPT师傅建议我去使用cvt创建自定义模式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-1" data-lang="1"><span class="line"><span class="cl">cvt 2560 1440 240
</span></span><span class="line"><span class="cl">xrandr --newmode &#34;2560x1600_240.00&#34; 808.75 2560 2792 3072 3584 1440 1443 1448 1493 -hsync +vsync
</span></span><span class="line"><span class="cl">xrandr --addmode DP-1 &#34;2560x1600_240.00&#34;
</span></span><span class="line"><span class="cl">xrandr --output DP-1 --mode &#34;2560x1600_240.00&#34;
</span></span></code></pre></div><p>类似这样，一个 RRSetCrtcConfig 错误，表明设置的显示模式参数超出了范围</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-1" data-lang="1"><span class="line"><span class="cl">X Error of failed request:  BadValue (integer parameter out of range for operation)Major opcode of failed request:  140 (RANDR)Minor opcode of failed request:  21 (RRSetCrtcConfig)Value in failed request:  0x78Serial number of failed request:  28
</span></span><span class="line"><span class="cl">Current serial number in output stream:  28
</span></span></code></pre></div><p>看下日志的 EDID (Extended display identification data) 怎么说</p>
<pre tabindex="0"><code class="language-sudo" data-lang="sudo">&gt; sudo get-edid | parse-edid
This is read-edid version 3.0.2. Prepare for some fun.
Attempting to use i2c interface
Problem requesting slave address: Device or resource busy
No EDID on bus 1
No EDID on bus 2
No EDID on bus 3
No EDID on bus 4
No EDID on bus 5
No EDID on bus 6
No EDID on bus 7
No EDID on bus 8
No EDID on bus 10
2 potential busses found: 9 11
Will scan through until the first EDID is found.
Pass a bus number as an option to this program to go only for that one.
256-byte EDID successfully retrieved from i2c bus 9
Looks like i2c was successful. Have a good day.
You seem to have too many extension blocks. Will not continue to parse
Something strange happened. Please contact the author,
Matthew Kern at &lt;pyrophobicman@gmail.com&gt;
</code></pre><p>问题：EDID 读取出现异常，显示有太多的扩展块；显示模式创建失败，可能是因为像素时钟超出了硬件支持范围</p>
<p>后面使用gtf创建不同刷新率和分辨率的样式，都不行</p>
<p>值得一提的是，Linux读取和显示EDID信息是使用read-edid这类或者X.Org Server这样去读取的，而在Windows中则是PowerStrip。而EDID和DDC又是老朋友，通过DDC传输（传奇I2C）</p>
<h2 id="成功的尝试">成功的尝试：</h2>
<p>先创建一个新的 xorg 配置文件，专门处理 EDID 问题</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-1" data-lang="1"><span class="line"><span class="cl">sudo nano /etc/X11/xorg.conf.d/20-amdgpu.conf
</span></span></code></pre></div><p>里面添加：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-1" data-lang="1"><span class="line"><span class="cl">Section &#34;Device&#34;
</span></span><span class="line"><span class="cl">    Identifier &#34;AMD&#34;
</span></span><span class="line"><span class="cl">    Driver &#34;amdgpu&#34;
</span></span><span class="line"><span class="cl">    Option &#34;TearFree&#34; &#34;true&#34;
</span></span><span class="line"><span class="cl">    Option &#34;DRI&#34; &#34;3&#34;
</span></span><span class="line"><span class="cl">    Option &#34;IgnoreEDID&#34; &#34;false&#34;
</span></span><span class="line"><span class="cl">    Option &#34;CustomEDID&#34; &#34;DP-1:/etc/X11/edid.bin&#34;
</span></span><span class="line"><span class="cl">    Option &#34;ModeValidation&#34; &#34;AllowNonEdidModes&#34;
</span></span><span class="line"><span class="cl">EndSection
</span></span></code></pre></div><p>然后去修改内核参数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-1" data-lang="1"><span class="line"><span class="cl">sudo nano /etc/default/grub
</span></span></code></pre></div><p>在 GRUB_CMDLINE_LINUX_DEFAULT 中加入：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-1" data-lang="1"><span class="line"><span class="cl">video=DP-1:2560x1600@200 amdgpu.dc=1 amdgpu.dpm=1 amdgpu.modeset=1  
</span></span></code></pre></div><p>这边我看了一眼我的配置文件这行还写着nvidia_drm.modeset=1，顺手给删了（相信暂时应该不会换回N系显卡）</p>
<p>修改后输入如下代码并重启</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-1" data-lang="1"><span class="line"><span class="cl">sudo grub-mkconfig -o /boot/grub/grub.cfg
</span></span></code></pre></div><p>Reboot后看一眼</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-1" data-lang="1"><span class="line"><span class="cl">&gt; xrandr --props
</span></span><span class="line"><span class="cl">DP-1 connected 2560x1600+0+0 (normal left inverted right x axis y axis) 0mm x 0mm
</span></span><span class="line"><span class="cl">        RANDR Emulation: 1 
</span></span><span class="line"><span class="cl">        non-desktop: 0 
</span></span><span class="line"><span class="cl">                supported: 0, 1
</span></span><span class="line"><span class="cl">   2560x1600    199.86*+
</span></span><span class="line"><span class="cl">    ...
</span></span></code></pre></div><p>说明解决了</p>
]]></content:encoded>
    </item>
    <item>
      <title>Turing</title>
      <link>http://localhost:1313/posts/think/tul/</link>
      <pubDate>Wed, 02 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/think/tul/</guid>
      <description>无价值的文章</description>
      <content:encoded><![CDATA[<h1 id="此篇目为游戏感想"><strong>此篇目为游戏感想</strong></h1>
<p>在游戏《Turing Complete》中，我遇到了如下关卡，令我印象深刻：</p>
<h2 id="相反数">相反数</h2>
<p><img loading="lazy" src="https://img.nanimonai.org/xiangfan.png" alt=""  />
</p>
<p>做到相反数，一个二进制的相反数其实就是它的补码。为了区分正负，二进制数用最高位来表示符号，1为负，0为正。用8位二进制数举例，0000 0001=1，1000 0001=-1。</p>
<p>十进制中相反数直接在数字前加负号就可，那么二进制的相反数怎么求呢？不管是十进制还是二进制，相反数的意义都是指：该数+该数的相反数=0。比如 0000 0011 + 它的相反数 = 0000 0000 ，那么 0000 0011的相反数=0000 0000 - 0000 0011 = 1111 1101，直观上理解就是一个数的相反数=<strong>对该数按位取反再加1</strong>。</p>
<p>下面从理论推导一下：对于某个不为0的二进制数来说，该数+它的相反数=0000 0000，那么该结果一定是由于进位溢出造成的（用二进制相加看，不要用十进制看），相当于1111 1111 + 0000 0001 = 0000 0000，用未溢出的值代替0000 0000，即 该数 + 它的相反数=1111 1111 + 0000 0001，⟶ 它的相反数 = 1111 1111 - 该数 +0000 0001，1111 1111 - 该数 就相当于对该数按位取反，所以二进制数的相反数就是对其按位取反加1。</p>
<p>我们自己理解的话0000 0011=3，它的相反数为-3=1000 0011，但0000 0011 + 1000 0011 != 0000 0000,所以计算机就引入了补码，相当于上面的相反数的表示。将人容易理解的二进制称为原码，计算机实际使用时用的是补码。正数的补码就是自己，负数的补码为按位取反加1。</p>
<p>对于1000 0011来说，若其为原码，则表示-3；若其为补码，则表示(-1)<em>2^7 + 1</em>2^1 + 1*2^0 = -125。</p>
<h2 id="计数器">计数器</h2>
<p>这题其实不算难，但是我楞了很久。</p>
<p>题目：</p>
<p><img loading="lazy" src="https://img.nanimonai.org/yaoqiu.png" alt=""  />
</p>
<p>如下设计:</p>
<p><img loading="lazy" src="https://img.nanimonai.org/jishu.png" alt=""  />
</p>
<p>寄存器会始终把数据存储并输出，并且直接输出到输出端。到下一段后，因为有ADD在，会+1（高电平就是1），然后再输出出来，重新写入到寄存器。左侧的高电平时为了始终启用寄存器的读取和写入功能。这样，在不覆盖的状态下，寄存器会每刻都+1。只需要用到一个选通器，选择让哪个数据覆盖到寄存器即可。</p>
<h2 id="锁存器等">锁存器等</h2>
<p>这个是我在游戏的提示里面看到的，由循环依赖衍生而出。与非门锁存器。游戏里面一般不允许出现循环依赖，但它在现实世界中是广泛存在的。</p>
<p>恶补触发器的原理，电平、脉冲和边缘触发器的不同等（参考数电课本）。然后对知识进行一个接轨，把所以已知的内容和生活的认知形成闭环。感觉整个体系对于现在态和未来态要有一定的敏感性，就是不能混淆，然后看时序图得认真看哪个是CLK。正常看时序报告即可，也算是把之前移位寄存器的课给补上了。</p>
<p>忽然就想起来这种概念我第一次接触是在哪里了，是mc的记忆电路。</p>
]]></content:encoded>
    </item>
    <item>
      <title>First try on RE</title>
      <link>http://localhost:1313/posts/tech/first-try-on-re/</link>
      <pubDate>Tue, 10 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/tech/first-try-on-re/</guid>
      <description>没有悲悯他的神明，命运倒向金钱的天平。</description>
      <content:encoded><![CDATA[<h1 id="第n次re碰壁">第N次RE碰壁</h1>
<p>​	近来参与尝试 BaseCTF 赛事中的“NEURO爱数学”题，结合官方WP进行总结。</p>
<p>​	题目共给出三项提示：</p>
<pre><code>1. flag为BaseCTF开头。z3可能存在多解，请尝试从数学角度解决。
2. 你知道的，11AdD8_result_21。
3. 多项式展开
</code></pre>
<p>​	下载下来是一个exe，选择拖入die。没什么问题：</p>
<p><img loading="lazy" src="https://img.nanimonai.org/DIE.png" alt=""  />
</p>
<p>​	再拖入ida端详。找到main后进入Pseduocode：</p>
<pre tabindex="0"><code>int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  FILE *v5; // rax
  __int64 v6; // rdx
  char v9[26]; // [rsp+50h] [rbp-80h] BYREF
  _BYTE v10[26]; // [rsp+6Ah] [rbp-66h] BYREF
  int Src[7]; // [rsp+90h] [rbp-40h] BYREF
  unsigned __int8 v12; // [rsp+AFh] [rbp-21h]
  __int64 v13; // [rsp+B0h] [rbp-20h]
  _QWORD *v14; // [rsp+B8h] [rbp-18h]
  int m; // [rsp+C0h] [rbp-10h]
  int k; // [rsp+C4h] [rbp-Ch]
  int j; // [rsp+C8h] [rbp-8h]
  int i; // [rsp+CCh] [rbp-4h]

  _main();
  feclearexcept(63);
  if ( fetestexcept(3) )
  {
    puts(&#34;Floating point exceptions are set, possibly being debugged.&#34;);
    exit(1);
  }
  if ( IsDebuggerPresent() )
  {
    puts(&#34;This program is being debugged. Exiting!&#34;);
    exit(1);
  }
  printf(&#34;I&#39;m practicing my neuro math skills. Give me nine integers: &#34;);
  scanf(
    &#34;%d %d %d %d %d %d %d %d %d&#34;,
    coeffs,
    &amp;dword_408044,
    &amp;dword_408048,
    &amp;dword_40804C,
    &amp;dword_408050,
    &amp;dword_408054,
    &amp;dword_408058,
    &amp;dword_40805C,
    &amp;dword_408060);
  printf(&#34;Hmm, let me think&#34;);
  v3 = __iob_func();
  fflush(v3 + 1);
  if ( IsDebuggerPresent() )
  {
    puts(&#34;This program is being debugged. Exiting!&#34;);
    exit(1);
  }
  putchar(46);
  v4 = __iob_func();
  fflush(v4 + 1);
  putchar(46);
  v5 = __iob_func();
  fflush(v5 + 1);
  puts(&#34;.&#34;);
  for ( i = -60; i &lt;= 59; ++i )
  {
    total = 0;
    power = 1;
    for ( j = 0; j &lt;= 8; ++j )
    {
      total += power * coeffs[j];
      power *= i;
      result = total;
    }
    if ( i == 44
      || i == 58
      || (::v12 = i + 37, (unsigned int)(i + 37) &lt;= 0x36)
      &amp;&amp; (v14 = &amp;::v5, v13 = (unsigned int)::v12, v6 = ::v5, (v12 = _bittest64(&amp;v6, (unsigned int)::v12)) != 0) )
    {
      if ( IsDebuggerPresent() )
      {
        puts(&#34;This program is being debugged. Exiting!&#34;);
        exit(1);
      }
      if ( result )
        goto LABEL_21;
    }
    else if ( !result )
    {
      if ( IsDebuggerPresent() )
      {
        puts(&#34;This program is being debugged. Exiting!&#34;);
        exit(1);
      }
LABEL_21:
      puts(&#34;Those aren&#39;t the right numbers. Try again!&#34;);
      return 1;
    }
  }
  if ( dword_408060 != 1 )
  {
    for ( k = 0; k &lt;= 8; ++k )
      coeffs[k] /= dword_408060;
  }
  if ( IsDebuggerPresent() )
  {
    puts(&#34;This program is being debugged. Exiting!&#34;);
    exit(1);
  }
  if ( dword_40805C == -80 &amp;&amp; dword_408058 == -358 )
  {
    printf(&#34;Correct! Here&#39;s the flag: &#34;);
    Src[0] = coeffs[0];
    Src[1] = dword_408044;
    Src[2] = dword_408048;
    Src[3] = dword_40804C;
    LOWORD(Src[4]) = dword_408050;
    HIWORD(Src[4]) = dword_408054;
    LOWORD(Src[5]) = dword_408058;
    HIWORD(Src[5]) = dword_40805C;
    LOWORD(Src[6]) = dword_408060;
    memcpy(v9, Src, sizeof(v9));
    memcpy(v10, Src, sizeof(v10));
    for ( m = 0; m &lt;= 51; ++m )
    {
      v9[m] ^= xorcode[m];
      putchar((unsigned __int8)v9[m]);
    }
    putchar(10);
    return 0;
  }
  else
  {
    printf(&#34;WRONG&#34;);
    return 1;
  }
}
</code></pre><p>​	本质上是一个代码审计加逻辑复写，需要输入九个数。程序前半段大概是这样的公式：</p>
<p>$$ x_1i^8 + x_2i^7 + x_3i^6 + x_4i^5 + x_5i^4 + x_6i^3 + x_7i^2 + x_8i^1 + x_9i^0 $$</p>
<p>​	而后是去计算(i-44)(i-58)(i-17)(i-6)(i-5)(i+4)(i+9)(i+37)————这个巨他妈难看，官方给出的答案是考虑本地模拟 or 动调。</p>
<p>​	程序要求用户输入9个整数，存储在 <code>coeffs</code> 数组中。使用这9个整数作为系数，构造一个8次多项式。然后在整数范围 [-60, 59] 内对这个多项式进行求值。对于每个 i 从 -60 到 59：初始化 total = 0 和 power = 1，对每个系数 j 从 0 到 8，然后：</p>
<ul>
<li>total += power * coeffs[j]</li>
<li>power *= i</li>
</ul>
<p>​	最终的 total 就是多项式在 i 点的值。期间验证程序检查多项式在特定点的值是否为0。这些特定点上述以及概括而出。如果上述条件满足，程序会将所有系数除以最后一个系数（如果最后一个系数不等于1）。最终检查： 程序检查调整后的第8个系数是否等于-80，第7个系数是否等于-358。所有条件都满足，程序使用调整后的系数生成一个标志（flag）。生成过程涉及将系数转换为字节，然后与预定义的 xor code 进行异或解密。</p>
<p>​	以下是复现：</p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main(){
    uint64_t v5 = 0x400C0210000001LL;  // 模拟位数组

    for(int x = -60; x &lt;= 60; x++){
        if(x == 44 || x == 58){
            printf(&#34;%d\n&#34;, x);
            continue;
        }

        unsigned int v12 = (unsigned int)(x + 37);

        if(v12 &lt;= 54 &amp;&amp; (v5 &amp; (1ULL &lt;&lt; v12))){
            printf(&#34;%d\n&#34;, x);
        }
    }

    return 0;
}
</code></pre><p>​	将其展开与上面对比就可以知道x1-x9的数值：</p>
<pre tabindex="0"><code>from sympy import symbols, expand
x = symbols(&#39;x&#39;)
polynomial = (x - 44) * (x - 58) * (x - 5) * (x + 37) * (x - 17) * (x + 9) * (x - 6) * (x + 4)
expanded_polynomial = expand(polynomial)
standard_form = expanded_polynomial.as_poly()
coefficients = standard_form.all_coeffs()
print(coefficients[::-1])
</code></pre><p>​	输出如下：</p>
<p><img loading="lazy" src="https://img.nanimonai.org/yunxing.png" alt=""  />
</p>
<p>​	堂堂完结，代入即可得到flag。</p>
<p>​	（笔者注：使用cmd打开做，不然那个flag一闪就过去了。）</p>
<p>​	（事后看了师傅的直播，发现在coeffs这个地方ida里面，它九个整数的地址是连续的，所以可以直接右键改一下，看成一个数组就行）</p>
]]></content:encoded>
    </item>
    <item>
      <title>Electronics Design Contest 1</title>
      <link>http://localhost:1313/posts/tech/electronics-design-contest-before/</link>
      <pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/tech/electronics-design-contest-before/</guid>
      <description>无法逃避迷雾丛林，失去了星辰的指引。</description>
      <content:encoded><![CDATA[<p>应某人之邀，写文以记述经历，即使失败，也可以给后人留下一点宝贵经验。</p>
<p>事实证明他是正确的。</p>
<p>关于自制PCB的环节进行简述：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="m">1</span><span class="l">. 嘉立创画图</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="m">2</span><span class="l">. 生成文件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="m">3</span><span class="l">. 导出掩膜(电路的镜像)，打印在掩膜纸上</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="m">4</span><span class="l">. 压印，采用热转印机</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="m">5</span><span class="l">. 蚀刻，环保腐蚀液蚀刻</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="m">6</span><span class="l">. 镀锡 (锡膏刷在铜板上，上加热台) (可选步骤)</span><span class="w">
</span></span></span></code></pre></div><p>这是截止到2024年8月28日的生产线，未来会进行改进。这样只能蚀刻出单层板，如果有一些被隔开如VCC、VEE时需要填充区域飞线。热转印的时候需要注意，过程高温需要有人看守，切割铜板切勿戴手套。蚀刻步骤时需要戴一次性手套，不能直接接触腐蚀液。使用专用的烧杯盛放腐蚀液，烧杯加热台加热烧杯使其蚀刻更快。但不宜过久，导致可能的掩膜脱落线路被蚀刻。如需打孔需要注意小钻头的转速不能过高，会崩飞钻头，高速旋转的钻头飞出来是很可怕的。操作加热台镀锡的时候需要在锡融化的时候刮平，后面好上贴片或者飞线。</p>
<p>自制板子也有可能出现一些离奇的原因未知的问题，例如原理图相同的lcr电桥模块自制时波形非常始终不能令人满意，在进行修改的时候，我他妈把sma吹下来的时候直接把那个中间内孔的覆铜带下来了。传奇红温。后面尝试嘉立创打了一块就没问题，参考设计和抄板子也很重要。</p>
<p><img loading="lazy" src="https://s3.tebi.io/img.nanimonai.org/lcr.png" alt=""  />
</p>
<p>剩下非常多的是经验的区别，亲身经历后无法解决，借鉴又借鉴不到类似情况的东西，就会红温。时机恰当的时候，共地不完整也会干碎心态。</p>
<p>(未完待续&hellip;)</p>
]]></content:encoded>
    </item>
    <item>
      <title>BabyRSA</title>
      <link>http://localhost:1313/posts/tech/babyrsa/</link>
      <pubDate>Fri, 19 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/tech/babyrsa/</guid>
      <description>初试Crypto</description>
      <content:encoded><![CDATA[<h1 id="为什么研究这个">为什么研究这个</h1>
<p>我是🕊大王，本来4.6一比完就想写了，硬鸽到今天。主要也是因为一堆作业考试给应付得手忙脚乱的。</p>
<p>这个是我们校内的CTF中的一个题目名为“babyrsa”，下载下来之后是一个babyrsa.py，于是我试图认真地学一下rsa的知识。在《密码编码学与网络安全》这本书中指出：很多的公钥密码体制的理论都基于数论，如果读者接受本章中给出的结论，那么便不必严格地理解数论的有关知识。然而，要完全理解公钥算法，就需要理解这些数论知识。</p>
<p>然而，我对于数论的认知完全停留在初二那个暑假去学院数竞培训的时间，当时有一位老师专门讲到了数论，我第一次听到“模十同余”这个概念，也第一次接触到所谓的中国剩余定理（在当时我的注意力基本都被解析几何和四点公圆的奇葩题目给吸引住了）</p>
<h1 id="自使疑始释">自使疑始释</h1>
<p>回到主题，在公钥密码体制中基本由6个部分组成：</p>
<p><strong>明文</strong>：这是原始未加密的信息或数据，是加密过程的输入。</p>
<p><strong>加密算法</strong>：这是一系列用于将明文转换为密文的规则和步骤。在公钥加密中，这个过程利用了公钥。
公钥：这是一个数字证书，用于加密明文或验证签名，公开可获取。任何人都可以使用公钥来加密信息，但只有持有对应私钥的接收者能够解密。</p>
<p><strong>密文</strong>：经过加密算法处理后产生的加密过后的信息或数据，只有拥有相应私钥的人才能解密回明文。</p>
<p><strong>解密算法</strong>：这是一系列用于将密文转换回明文的规则和步骤。在公钥加密中，这个过程利用了私钥。</p>
<p><strong>私钥</strong>：这是一个数字证书，用于解密收到的信息或进行数字签名，应当被密切保护，不对外公开。私钥确保只有密钥的持有者才能解密那些用对应公钥加密的信息。</p>
<p>1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为&quot;Diffie-Hellman密钥交换算法&quot;。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。</p>
<p>这种新的加密模式被称为&quot;<strong>非对称加密算法</strong>&quot;。如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</p>
<p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。</p>
<p>（2）甲方获取乙方的公钥，然后用它对信息加密。</p>
<p>（3）乙方得到加密后的信息，用私钥解密。</p>
<p>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的&quot;非对称加密算法&quot;。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。</p>
<p>RSA是一种分组密码，其密文和明文都是0~n-1之间的证书，通常n是1024位的二进制数或309位的十进制数，也就是说n&lt;2^1024。明文分组进行加密，每个分组的二进制值均小于n。</p>
<p>（1）选定两个素数(p,q)（保密的，选定的）</p>
<p>（2）n=pq(公开的，计算得出的)</p>
<p>（3）e,满足gcd(φ(n),e)=1,1&lt;e&lt;φ(n)（公开的，选定的）</p>
<p>（4）d≡e^-1(mod φ(n))（保密的，计算得出的）</p>
<p>私钥为{d，n}，公钥为{e,n}。假设A公布了密钥，用户B要发送消息M给A，那么用户B只需要计算 M≡C^d(mod n)并发送给C；在接收端，用户A计算M≡C^d(mod n)以解出消息M。</p>
<p>需要注意的是，在rsa加密解密中都需要计算某个整数模n的整数次幂，如果先求整数的幂再模n，soleidei，中间的结果会非常大。可以运用模算术的性质解决，去简化为对中间的计算结果模n。因为在rsa中使用的指数很大，所以还得考虑幂运算的效率问题如果正常计算x^16次方，需要进行15次乘法，这样子的话对加密解密的时间就上了很大的压力。但是可以取重复每个部分结果的平方（2^2,2^4,2^8,2^16）,就只需要四次乘法了。</p>
<p>给出普遍的计算a^b mod n的算法，其中里面的变量c不是必须的，整数b表示为二进制数，引入它为了解释算法，c的终值即使指数值：</p>
<pre tabindex="0"><code>c←0;f←1
for i←k downto 0
	do c←2*c
	   f←(f*f) mod n
	if bi=1		（bi i是下标）
		then c←c+1
		  f←(f*a) mod n
	return f
</code></pre><p>我是懂哥，比赛看到这里假装自己懂了，然后开始看题目。后来我发现对于真正的rsa系列题目还有一系列难点涉及到e的取值（3，17，65537），各个情况的互相求解，不同的攻击方式等等，也要了解如中国剩余定理，费马定理，Miller-Rabin算法什么的，暂且按下不表。</p>
<h1 id="baby的rsa">Baby的rsa</h1>
<p>来看一下源码：</p>
<pre tabindex="0"><code>from gmpy2 import lcm
from Crypto.Util.number import getPrime, bytes_to_long

p = getPrime(1024)
q = getPrime(1024)
n = p*q
e = 54666
h = lcm(p - 1 , q - 1)
flag = b&#39;FCTF{***********}&#39;
m = bytes_to_long(flag)
c = pow(m, e, n)
print(&#39;n: &#39;, n)
print(&#39;h: &#39;, h)
print(&#39;c: &#39;, c)




&#39;&#39;&#39;
n:  25527104228224088488040470054859297799684430729586201999927539150044992353999083976287914924970569469434686168557247480896928199907052200737794107820101535432772515334456482673511185210116841919416618006696356771202410487435695207310741143088507315599413718818919895412368893805095614918899139207456629111515498628424508456173008212962396577655489900115537922862725514355690650346542020236913649627901430140820374812887483132677589636744805036428604336253688728768629554430310965303561197842773841768036265483485885167914975226451364872214945774294272151759555341126251417977165442601848916571897507614450138696307441
h:  3190888028528011061005058756857412224960553841198275249990942393755624044249885497035989365621321183679335771069655935112116024988381525092224263477512691929096564416807060334188898151264605239927077250837044596400301310929461900913842642886063414449926714852364986926546111725636951864862392400932078638939397162813314446093112008451870874459413340817966632865485406320788272316381137437957674310631802876313435533326327324210320100692584743680300917008843045504725648240011406960704841222641567549521400885041138306803979812904472944466100873729786606242613061006721938847831340052029664934674085291935568007804584
c:  13816656057233504242725466607519098922616296851282996573245636803888321169952138063011430581813327223855035775201965978271601144858474586480811825971179893352623779199435743915535990803704703901640138034283878850535619383284762202523145531803148037944606221169858890092284283768859214489478888725916054874525393017572123038563581085488781982829726844109883458439559508856073477596828594786184067989967020470472291721891068880110540699901476565507918536144452248311628215837448639176024403880919704090284307989085868140402906218076204485172179740170107661474514833980476371750724966421481356221210695767530318458804012
</code></pre><p>看起来非常吓人。</p>
<p>在这个位数的情况下，我不知道能不能把他分解，使用一些常规手段得等上好久，觉得可能没那么简单。</p>
<p>注意到，e = 54666，并不是一个素数。目前我们只知道e，h，c，n。我刚开始以为可以直接从h和n直接逆推出p和q，还是太天真了。然后去网络上找，发现有人讲过这种题型，但是讲的都有点奇怪，我当时没懂，又自己开始琢磨。在探索过程中，我发现一个名曰“欧几里得算法”的东西可能有所帮助，于是我去看了一下wiki，发现就是辗转相除法其实。</p>
<pre tabindex="0"><code>def gcd(a, b):
    while b != 0:
        t = a % b
        a = b
        b = t
    return a
</code></pre><p>想必这个迭代，各位都有印象，它广泛地出现在编程题目中。当然也有：</p>
<pre tabindex="0"><code>def gcd(a, b):
    return a if b == 0 else gcd(b, a % b)
</code></pre><p>扩展欧几里得算法是用于计算两个整数a和b的最大公约数以及满足贝祖等式ax+by=gcd(a,b)的整数解x和y的一种算法。</p>
<p>评价是有点汗流浃背了，我开局第一题做的这一题（一见钟情），到晚上都没想好是什么个思路。翻阅资料，了解到大素数和大整数的位数是尤为重要的，可以有奇淫巧技来破解。观察到n和h的位数相近，继续学习并尝试使用下列代码。</p>
<pre tabindex="0"><code>h = 
e = 
c = 
n = 

print(len(bin(h)[2:]))
print(len(bin(n)[2:]))

#bin(h)将变量 h 转换为二进制字符串表示；[2:]切片操作，从第三个字符（二进制数的起始字符）开始截取到末尾，去掉了前面的 &#39;0b&#39;，这是二进制数前缀；len()：获取字符串的长度，即二进制数的位数。
</code></pre><p>输出2045和2048。</p>
<p>n是两个大素数p和q的乘积。而h是p-1和q-1的最小公倍数。因此，它们的位数可以用来估计p和q的位数。具体地说，如果n是一个 2048 位的数字，那么p和q通常会是1024位的素数。</p>
<p>进行穷（ti）举（shen）攻击，进行遍历，差三位所以选择（4，8）。这应该算是…穷举吧，试着当作φ的倍数去解，然后使用扩展欧几里得解密钥。其中，模逆是指对于给定的两个整数a和n，如果存在一个整数b，使得 ab≡1(mod n)，那么b就是a在模n意义下的乘法逆元，通常记作a−1。当然，≡表示模同余关系</p>
<p>复习一下上面的解密，其中M≡C^d(mod n)，d就是指数e的模φ的模逆，(e*d)%φ(n)=1 。需要指出的是，加密操作是指数运算，解密操作则是对密文进行模幂运算，其结果是明文的平方。因此，解密后的结果 m_2 是明文的平方。</p>
<p>最终代码如下：</p>
<pre tabindex="0"><code>import gmpy2
from Crypto.Util.number import *
h =
e =
c =
n =

#print(len(bin(h)[2:]))
#print(len(bin(n)[2:]))

for gcd_val in range(4, 8):
    phi = h * gcd_val
    try:
        d = gmpy2.invert(e // 2, phi)
        m_2 = pow(c, int(d), n)
        flag = long_to_bytes(gmpy2.isqrt(m_2))
        print(flag)
    except ZeroDivisionError:
        continue
</code></pre><p>可以得出 b&rsquo;FCTF{***********}&rsquo;（真实值是一串字符），提交即可。</p>
<p><del>这种题型算是比较基础的题目，当然让我学到很多，感觉很有意思。</del></p>
<h1 id="一语点醒撒比人">一语点醒撒比人</h1>
<p>（4.21更新，绷不住了有点）</p>
<p>但是，经“客服4.5 9:00-12：00”点拨，我霍然觉得自己就是个傻子。</p>
<p>他指出：e并不是一个素数，可以执行：</p>
<pre tabindex="0"><code>print(((p-1)*(q-1))/h)
</code></pre><p>可以得出为2。一般来说，对于任意两个数a,b，有LCM(a,b)×GCD(a,b)=a×b。由于p和q是素数，GCD(p−1,q−1)GCD(p−1,q−1)很可能是1。h=LCM(p−1,q−1)≈(p−1)×(q−1)，当你用LCM（p-1，q-1）除以（p-1）*（q-1）时，你本质上是在用它自己，或者用一个非常接近它自己的数字来除以它。结果应该接近1。在（p-1）和（q-1）中存在一个小的公因子，会使得LCM略小于h。比如这里输出为2意味着 (p-1) 和 (q-1) 共有一个因子，导致它们的最小公倍数恰好是乘积的一半。那么，上述的代码就显得非常的傻，我们完全可以利用如下代码得出结论：</p>
<pre tabindex="0"><code>import gmpy2
from Crypto.Util.number import long_to_bytes

h =
e =
c =
n =
gcd_val = 2
phi = h * gcd_val
d = gmpy2.invert(e // 2, phi) 
m_2 = pow(c, int(d), n)
flag = long_to_bytes(gmpy2.isqrt(m_2))
print(flag.decode(&#39;utf-8&#39;))
</code></pre><p>太难绷了babyrsa，真的是一题宝宝题啊。</p>
<p>于是回到博客的开篇句：</p>
<p>“吾魂兮无求乎永生，竭尽兮人事之所能”
——Pindar</p>
<p><strong>DONE.</strong></p>
<p>参考文章<a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">(Sir,this way.)</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Research on the principle of automatic punch-in</title>
      <link>http://localhost:1313/posts/tech/research-on-the-principle-of-automatic-punch-in/</link>
      <pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/tech/research-on-the-principle-of-automatic-punch-in/</guid>
      <description>应用</description>
      <content:encoded><![CDATA[<h1 id="这是什么">这是什么</h1>
<p>近日，打卡更新方式，由之前转移到了某一新平台上。求知欲驱使进行研究。写的不周，还请包含，同时我要非常感谢lockey中的一位热心朋友不厌其烦地为我指点迷津。</p>
<h1 id="如何实现">如何实现</h1>
<h2 id="第一步">第一步</h2>
<p>首先是获取签到的数据。</p>
<p>先去官网下载.apk文件，而众所周知，.apk是一种压缩文件，所以直接解压出来，查找一下发现是rsa，然后思考如何拿到公钥。
<img loading="lazy" src="https://img.nanimonai.org/bunan.png" alt=""  />
</p>
<p>继续find寻找.pem，找到一个证书（本人搞到这里有点绷不住了，真的难绷）</p>
<p><img loading="lazy" src="https://img.nanimonai.org/pem.png" alt=""  />
</p>
<p>写如下代码以还原出公钥：</p>
<pre tabindex="0"><code>import OpenSSL.crypto

cert_text = &#34;&#34;&#34;
-----BEGIN CERTIFICATE-----
MIIFizCCA3OgAwIBAgIDAJY4MA0GCSqGSIb3DQEBCwUAMIGAMQswCQYDVQQGEwJD
TjEQMA4GA1UECAwHQmVpamluZzEMMAoGA1UECgwDTVNBMREwDwYDVQQLDAhPQUlE
X1NESzEeMBwGA1UEAwwVY29tLmJ1bi5taWl0bWRpZC5zaWduMR4wHAYJKoZIhvcN
AQkBFg9tc2FAY2FpY3QuYWMuY24wHhcNMjQwMTA3MTQ0ODU1WhcNMjUwMTA3MTQ0
ODU1WjB9MQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpamluZzEQMA4GA1UEBwwH
QmVpamluZzEQMA4GA1UECgwHd2phY2tlcjEWMBQGA1UEAwwNY29tLnlpYmFuLmFw
cDEgMB4GCSqGSIb3DQEJARYRd2FuZ2ppZTJAeWliYW4uY24wggIiMA0GCSqGSIb3
DQEBAQUAA4ICDwAwggIKAoICAQCyGC9T3GW4BSsvnVNqb8+HlnjJAQvTPd7H13m1
f945uUsUYYMaaZuICYjb4qefZUyQgyxBUTYfBOTpE7ccdcNoZgCp05RTng30zvkc
4pjawJIkNeIC2NGlN7RquO4Ka/06LSuq5N+bfL78E0MwZAinoxSswf/yNY5R1LJ2
b3I7BnW7rVSb7KbB0Q4z5KmuJ04hPVl7BtSdfVnvnRVTBDRm/cMgyupEl+CCGW8H
UejzPHdHeHRK1rx7fuwQI+5jgMmDYRNXZD4AmJ0vClurQR5avN2xOuxB8HbtB+lQ
itsNnQCvYY1Xp4s7FtfmT6JzDNQ//vRgXxYrOaVFfoY/ugrO+SfZtqej+mdKR3Kg
OaAA75t8zcJfM6WGrbPJl3xHc2bhD4kGwRkTAcHJ7WQOIrWz85CPCfIoYh8nZlBl
sCNamJJh6Pl2nAtmnfMtDuYZJo/2QK6J/KFtywsYIekU6fiRsJaaunBf5sD9Ixbv
JcRRB+HRCsySKYEg8z7Xlh90fHimfUgT0Gt44/o+nzPh7Cq9Ay6dWtMxYFx78Z1e
papOJdUNpZWIET8wQHriJmbJ18TlidGRAW85kW2ka2cr4u6Ed68JQa+nN+kbS0dD
euvOBGOsiqqCy5aeA0oz88HRWWIga02PLTZbEs4PdYrNzHWCISjnk34KpwwxYJUn
6Zpy1wIDAQABoxAwDjAMBgNVHRMBAf8EAjAAMA0GCSqGSIb3DQEBCwUAA4ICAQAk
o30meLI9Un/7KoUekSMhterJ6K11cHKAa+WQqqzp8If+gIhjsyYk7Wf1fgStvoNu
jILWSAfe2C2k74QrlVsUFXue2Ekc+eyDbUhwOi4rVju68/eu4HSpdIUbFQ7ZpivC
adjw7qfN90sp6S+O/dDQ9SzUPBpjMQQ6ZvSTFv7TtZ1cjzOpcfogrDGyOe+mE5Rv
xT3IaWFBcY2fe8lh+/7mJ27A5XgCka1LTZ2OFwI4d1gPWRhwi7R0p4rGhtmk2JJG
viz1rPn8pBBeR5zcwHFuDAbL/1C9d6rZ5lajycrdPZzbcuFAzx7NPafiMsyMYwBK
9oQDIjS5UmfMt+lMFk37yCesFqxq/DOIPm1Hz3N1t5RpcZuwIkCzXYhtOkCbu9SZ
xKqxztpcA5ySf3DWH4TIxKGXxIlC5pr2F4HsmKDIAO/1O6HXI0Bo+s/3KsDS/IMV
nlqKu1WUKUZJebjN/CL61ChfHjkmogslgTkQpJnGsWsix3v0nBFjpbOm/oXYYMJy
p+aMzppKaLx3mniXW/kimteNKu8EdeE7x/QeEIk5IUotfRPAeydVk9yqf+c4ClS9
YwVFAqIDzbC3nLBBXb36WNOoG+MFwWkjKoPhtIoLysTN1gNuFYUlJ1JptoP0Pe0I
k5FWnRRk1vKUktYUfMJE4PQg4sWxZhGkKrGU5zVLsg==
-----END CERTIFICATE-----
&#34;&#34;&#34;

cert=OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert_text)

public_key=OpenSSL.crypto.dump_publickey(OpenSSL.crypto.FILETYPE_PEM, cert.get_pubkey()).decode(&#34;utf-8&#34;)

print(public_key)
</code></pre><p>得出公钥就够用了：</p>
<p><img loading="lazy" src="https://img.nanimonai.org/rsa.png" alt=""  />
</p>
<h2 id="第二步">第二步</h2>
<p>获取cookie，参考github可得：</p>
<pre tabindex="0"><code>
def auth(self):
    COOKIES = {}
    CSRF = &#34;00000000000000000000000000000000&#34;
    HEADERS = {
        &#34;Origin&#34;: &#34;m.yiban.cn&#34;,
        &#34;origin&#34;:&#34;api.uyiban.com&#34;,
        &#34;origin&#34;:&#34;https://c.uyiban.com&#34;,
        &#34;authority&#34;: &#34;api.uyiban.com&#34;,
        &#34;AppVersion&#34;: &#34;5.0.17&#34;,
        &#34;x-requested-with&#34;: &#34;com.yiban.app&#34;,
        &#34;user-agent&#34;:&#34;Mozilla/5.0 (Linux; Android 12; XIAOMI Build/SKQ1.211006.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/112.0.5615.48 Mobile Safari/537.36;webank/h5face;webank/1.0 yiban_android/5.0.17&#34;
        }
    iapp = requests.get(&#34;http://f.yiban.cn/iapp/index?act=iapp7463&#34;, headers=HEADERS, allow_redirects=False, cookies=COOKIES) # 利用 loginToken 访问获取 verifyRequest跳转数据
    # 此处cookie带有 &#34;loginToken&#34; = “cdd6d4432743414c9e1faf3e792*****”
    act = iapp.headers[&#34;Location&#34;] # 返回302跳转目标
    verifyRequest = re.findall(r&#34;verify_request=(.*?)&amp;&#34;, act)[0] # 正则取302跳转目标，得到 verify_request 数据
    json = requests.get(&#34;https://api.uyiban.com/base/c/auth/yiban?verifyRequest=&#34; + verifyRequest + &#34;&amp;CSRF=&#34; + CSRF, headers=HEADERS, allow_redirects=False, cookies={&#39;csrf_token&#39;: CSRF})
    cookies = requests.utils.dict_from_cookiejar(json.cookies) # 获取cookie
    Attendancecookies = cookies # 签到cookies赋值self.Attendancecookies
    print(&#39;Location:&#39;,act,&#34;\n&#34;)
    print(&#39;cookies:&#39;,Attendancecookies,&#34;\n&#34;)
    
    ###打印数据：
    Location: https://c.uyiban.com/#/?verify_request=c9e814****53de92ccc&#39;, &#39;cpi&#39;: &#39;eyJD******%3D%3D&#39;, &#39;is_certified&#39;: &#39;1&#39;}    
    cookies: {&#39;PHPSESSID&#39;: &#39;fa1a28bc38cc**c4b1e87a8ce51f****&#39;, &#39;cpi&#39;: &#39;eyJDaG**%3D%3D&#39;, &#39;is_certified&#39;: &#39;1&#39;}
</code></pre><p>All right. 现在只需要PHPSESSID.</p>
<h2 id="第三步">第三步</h2>
<p>进行ADB调试，其中挺复杂的。我未来也要尝试一下有没有更加简单的调试方法。首先你PC得有Chrome，Firefox就不行。我Linux上面用的是Chromium。第一次尝试的时候移动端使用的是旧版本的Kiwi Browser，导致 chrome://inspect/#devices 这个界面没有inspect fallback选项。更新就行了。</p>
<p><img loading="lazy" src="https://img.nanimonai.org/404.png" alt=""  />
</p>
<p>在kiwi上找到Network Conditions，把用户代理叉掉并自定义写上MicroMessenger。</p>
<p><img loading="lazy" src="https://img.nanimonai.org/network.png" alt=""  />
</p>
<p>这个其实可以直接在控制台输入命令获取（忘记截图了，可以自己去试一下）：</p>
<pre tabindex="0"><code>console.log(&#34;User-Agent:&#34;, navigator.userAgent);
</code></pre><p>直接从中间几个开始分析（其实是依葫芦画瓢），能够成功找到https://api.uyiban.com/nightAttendance/student/index/signIn?CSRF=&hellip;</p>
<p>以及https://api.uyiban.com/nightAttendance/student/index/signPosition?CSRF=&hellip;</p>
<p>这样就可以进行测试，API 是 RESTful 标准。从登录开始追踪，使用curl去调试。</p>
<p><img loading="lazy" src="https://img.nanimonai.org/gongzuotai.png" alt=""  />

<img loading="lazy" src="https://img.nanimonai.org/yes.png" alt=""  />
</p>
<p>错误的都是{&lsquo;code&rsquo;: 500, &lsquo;msg&rsquo;: &lsquo;非法签到&rsquo;, &lsquo;data&rsquo;: None}	0.0</p>
<p>签到成功会返回{&lsquo;code&rsquo;: 0, &lsquo;msg&rsquo;: &lsquo;&rsquo;, &lsquo;data&rsquo;: True}</p>
<h2 id="第四步-前人的智慧">第四步 前人的智慧！</h2>
<p>脚本是大爱无私宽仁的Mike修改的，最初版是来自<a href="https://wcyuns.cn/archives/%E6%98%93%E7%8F%AD%E6%99%9A%E7%AD%BE%E8%84%9A%E6%9C%AC">this</a>思路也是借鉴于此，上面也算是重走一遍。真所谓巧夺天工，令人敬佩！</p>
<pre tabindex="0"><code>import json
import re
import sys
import os
import pickle
import time
import urllib
import jsonpath
from urllib import parse
import random
import requests
import numpy
import base64
import msvcrt
try:
    from Crypto.Cipher import PKCS1_v1_5
    from Crypto.PublicKey import RSA
except ModuleNotFoundError:
    print(&#34;缺少pycryptodome依赖！程序将尝试安装依赖！&#34;)
    os.system(&#34;pip3 install pycryptodome -i https://pypi.tuna.tsinghua.edu.cn/simple&#34;)
    os.execl(sys.executable, &#39;python3&#39;, __file__, *sys.argv)

def encryptPassword(pwd): # 登录密码加密
    # 密码加密
    PUBLIC_KEY = &#39;&#39;&#39;-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAzq0rgsM++ZxLRGHpdfre
Hu6UXhdlUS5P2WOxRG14qU8/iWSb/CkOqgOl8AGcOhlthkvolCdpUvVcVsVUxBv0
YRN0Jb64zPrn5aLVwQT4RJn5tXvoqLdHIXis7pljXAMDPVZOVlWJkDMk8YU6HDaA
MqsD6l5p9lg2LMP4OhMgaPX+CkO370LB5vRjJTHp03n+IqfxXoC7DEd+kxRIEM2C
EDgUSYDJBDgwBvGALZmvB/a1b0im9t1P/EmnuE7uN9NRFoWyVpOiEwo/Ti7rmJGf
qNT3vvtfWo4nXsm1rYQXsPayoKDSRaba3gFY/1SYWLAuSO2q2da5ZCcsAk5RKy0V
c1hUg8n6y0YLAvuzoXY5VyNMXkhH5Zc5Kg64b5RxILeZpZG0MV7GFY3sw//k7SNg
darKT8A0Iv3l3lfguX3HNi6dkf97kS/EiA0tbkIB/JNjv13mq8HL7LijRt2hkKqP
PhQW88xC/exZilU5pAavoZOPuZIOTUHqtpRq4ZeKl+wDf+e5lPYFDpihWGjplGpa
4BOSmGeo/SyVFPji9QF4Pk0DRJF/NjwJoAC60xHAVt5Z4gQSOOOjNZDCswA0ry2L
e8m5cv5vPGY75uVrGqALQ6Xm961PPc5cJ1q7tmEZMj+z5HE7tgAdhiPI6acKgrAv
+1k4N0OVqKamMS+PVpD05hUCAwEAAQ==
-----END PUBLIC KEY-----&#39;&#39;&#39;
    cipher = PKCS1_v1_5.new(RSA.importKey(PUBLIC_KEY))
    cipher_text = base64.b64encode(cipher.encrypt(bytes(pwd, encoding=&#34;utf8&#34;)))
    return cipher_text.decode(&#34;utf-8&#34;)
####################################################################################################################################################################################################
####################################################################################################################################################################################################

class yiban:
    COOKIES = {}
    def __init__(self, mobile, password): # 全局变量
        self.mobile = mobile # 登录手机号
        self.password = password # 登录密码
        self.session = requests.session()
        self.HEADERS = {
            &#34;Origin&#34;: &#34;m.yiban.cn&#34;,
            &#34;origin&#34;:&#34;api.uyiban.com&#34;,
            &#34;origin&#34;:&#34;https://c.uyiban.com&#34;,
            &#34;authority&#34;: &#34;api.uyiban.com&#34;,
            &#34;AppVersion&#34;: &#34;5.1.2&#34;,
            &#34;x-requested-with&#34;: &#34;com.yiban.app&#34;,
            &#34;user-agent&#34;:&#34;Mozilla/5.0 (Linux; Android 12; Redmi K30 Pro Build/SKQ1.211006.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/112.0.5615.48 Mobile Safari/537.36;webank/h5face;webank/1.0 yiban_android/5.0.17&#34;
            }
        self.Attendancecookies = {}
        self.CSRF = &#34;00000000000000000000000000000000&#34;

    def login(self): # 登录
        params = {
            &#34;mobile&#34;: self.mobile, #登录手机号
            &#34;password&#34;: encryptPassword(self.password), #RSA加密后的登录密码
            &#34;ct&#34;: &#34;2&#34;, #固定参数
            &#34;identify&#34;: &#34;0&#34;, #固定参数
        }
        # 配置登录数据
        response = requests.post(&#34;https://m.yiban.cn/api/v4/passport/login&#34;, data=params, allow_redirects=False, cookies=self.COOKIES, headers=self.HEADERS).json()
        if response is not None and response[&#34;response&#34;] == 100:
            self.access_token = response[&#34;data&#34;][&#34;access_token&#34;]
            self.HEADERS[&#34;Authorization&#34;] = &#34;Bearer &#34; + self.access_token
            # 增加cookie
            self.COOKIES[&#34;loginToken&#34;] = self.access_token
            print(&#39;用户信息:&#39;,response,&#34;\n&#34;)
            print(&#39;loginToken:&#39;,self.access_token,&#34;\n&#34;)
            print(&#39;用户姓名:&#39;,response[&#34;data&#34;][&#34;user&#34;][&#34;name&#34;],&#34;\n手机号码：&#34;,response[&#34;data&#34;][&#34;user&#34;][&#34;phone&#34;])
            return 1
        else:
            print(response)
            return self.mobile
        #返回https://f.yiban.cn/iapp/index?act=iapp7463所需的Cookie“loginToken=ce196e5fb2900bc35b44e1f1b4ed****”


        #通过获取的loginToken访问iapp后台得到值verifyRequest
        #利用verifyRequest访问api获取签到用的cookie
        #返回cookie内容范例
        #{&#39;PHPSESSID&#39;: &#39;1aef34b976315dca8400711255f1a9af&#39;, &#39;cpi&#39;: &#39;eyJDaGFubmVsIjoieWliYW......TliNWViZTUxYWMifQ%3D%3D&#39;, &#39;is_certified&#39;: &#39;1&#39;}
        #PHPSESSID为关键值，有这一个参数就可以访问签到等相关内容
        #cpi 使用base64编码 有个人相关信息
    def auth(self): # 获取签到cookie
        iapp = requests.get(&#34;http://f.yiban.cn/iapp/index?act=iapp7463&#34;, headers=self.HEADERS, allow_redirects=False, cookies=self.COOKIES) # 利用 loginToken 访问获取 verifyRequest
        act = iapp.headers[&#34;Location&#34;] # 返回302跳转目标
        verifyRequest = re.findall(r&#34;verify_request=(.*?)&amp;&#34;, act)[0] # 正则取302跳转目标，得到 verify_request 数据
        json = requests.get(&#34;https://api.uyiban.com/base/c/auth/yiban?verifyRequest=&#34; + verifyRequest + &#34;&amp;CSRF=&#34; + self.CSRF, headers=self.HEADERS, allow_redirects=False, cookies={&#39;csrf_token&#39;: self.CSRF})
        #访问api获取cookie CSRF值按此可用，只验证位数
        cookies = requests.utils.dict_from_cookiejar(json.cookies) # 获取cookie
        self.Attendancecookies = cookies # 签到cookies赋值self.Attendancecookies
        print(&#39;Location:&#39;,act,&#34;\n&#34;)
        print(&#39;cookies:&#39;,self.Attendancecookies,&#34;\n&#34;)
        return

    def authorization(self, testauth): # 授权校本化
        self.testauth = testauth
        authhtml = requests.get(&#34;https://oauth.yiban.cn/code/html?client_id=95626fa3080300ea&amp;redirect_uri=https://f.yiban.cn/iapp7463&#34;) # 利用 loginToken 访问获取 verifyRequest
        HTML_PUBLIC_KEY = re.search(&#39;&lt;input type=&#34;test&#34; id=&#34;key&#34; value=&#34;((?:.|\n)+)?&#34; style=&#34;display:none&#34;&gt;&#39;,authhtml.text)[1] # 获取网页签到加密 password 证书
        webcookies = requests.utils.dict_from_cookiejar(authhtml.cookies) # 获取校本化授权 cookie    登录需要
        print()
        print(&#34;获取的网页cookie:&#34;,webcookies)
        print(&#34;获取的网页加密证书:&#34;,HTML_PUBLIC_KEY,&#34;\n&#34;)
        HTML_cipher = PKCS1_v1_5.new(RSA.importKey(HTML_PUBLIC_KEY))
        HTML_cipher_text = base64.b64encode(HTML_cipher.encrypt(bytes(self.password, encoding=&#34;utf8&#34;)))
        HTML_cipher_decode = HTML_cipher_text.decode(&#34;utf-8&#34;)
        print(&#34;密码网页加密结果:&#34;,HTML_cipher_decode)
        webparams = {
            &#34;oauth_uname&#34;: self.mobile , # 账号
            &#34;oauth_upwd&#34;: HTML_cipher_decode , # 加密后密码
            &#34;client_id&#34;: &#34;95626fa3080300ea&#34;, # 应用端编号
            &#34;redirect_uri&#34;: &#34;http://f.yiban.cn/iapp7463&#34;, # 应用端回调地址
            }
        webauth = requests.post(&#34;https://oauth.yiban.cn/code/usersure&#34;, data=webparams, cookies=webcookies, headers=self.HEADERS).json()
        print(&#34;授权结果&#34;,webauth,&#34;\n&#34;)
        print(&#34;授权成功，返回获取签到信息中...&#34;)
        return

    def signPosition(self):
        Position = requests.get(&#34;https://api.uyiban.com/nightAttendance/student/index/signPosition?CSRF=&#34; + self.CSRF, allow_redirects=False, cookies={&#39;PHPSESSID&#39;: self.Attendancecookies[&#39;PHPSESSID&#39;], &#39;csrf_token&#39;: self.CSRF}, headers=self.HEADERS).json()
        if Position[&#34;code&#34;] == 0: # 判断是否登录成功
            print(&#34;校本化已授权，有晚签任务\n&#34;)
            print(&#34;可签到数据:&#34;,Position,&#34;\n&#34;)
            State=Position[&#34;data&#34;][&#34;State&#34;] # 获取状态码
            Msg=Position[&#34;data&#34;][&#34;Msg&#34;] # 获取返回信息
            StartTime=Position[&#34;data&#34;][&#34;Range&#34;][&#34;StartTime&#34;] # 获取签到开始时间
            self.StartTime =  StartTime
            EndTime=Position[&#34;data&#34;][&#34;Range&#34;][&#34;EndTime&#34;] # 获取签到结束时间
            pause = StartTime - int(time.time()) # 获取系统现在时间
            if State == 2: # 没有签到任务 如学校没有晚签
                print(&#34;您&#34;,Position[&#34;data&#34;][&#34;Msg&#34;])
                return
            else:
                if State == 3: # 已签到
                    print(&#34;[*] 签到接口返回数据：&#34;,Position[&#34;data&#34;][&#34;Msg&#34;])
                    return
                else:
                    self.Address=jsonpath.jsonpath(Position,&#39;$...Address&#39;)[0] # 获取可签到位置 地址
                    self.LngLat=jsonpath.jsonpath(Position,&#39;$...LngLat&#39;)[0] # 获取可签到位置 经纬度
                    self.lonss = &#39;%.6f&#39; %float(round(float(self.LngLat.split(&#34;,&#34;)[0]),3) + float(random.uniform(0.000100,0.000999))) # 根据地址随机修改经度后3位，达到每次定位位置不一样
                    self.latss = &#39;%.6f&#39; %float(round(float(self.LngLat.split(&#34;,&#34;)[1]),3) + float(random.uniform(0.000100,0.000999))) # 根据地址随机修改纬度后3位，达到每次定位位置不一样
                    if State == 0: # 已经到达签到时间
                        print(&#34;可以签到，立即执行！\n&#34;)
                        self.nightAttendance() # 签到跳转
                    else:
                        if State == 1: # 还未开始签到
                            pause = StartTime - int(time.time()) # 获取剩余时间
                            while pause &gt;= 60 :
                                list = [&#34;\\&#34;, &#34;|&#34;, &#34;/&#34;, &#34;—&#34;]
                                index = pause % 4
                                print(&#34;[*] 距签到时间还有 {} 秒 {}&#34;.format(pause,list[index]), end=&#34;\r&#34;, flush=True)
                                pause = StartTime - int(time.time())
                                time.sleep(1)
                            else:
                                while pause &lt;= 60 and pause &gt;=10 :
                                    print(&#34;[*] 距签到时间还有 {} 秒 {}&#34;.format(pause,list[index]), end=&#34;\r&#34;, flush=True)
                                    pause = StartTime - int(time.time())
                                    time.sleep(0.5)
                                else:
                                    while pause &lt;= 10 :
                                        print(&#34;[*] 距签到时间还有 {} 秒 {}&#34;).format(pause,list[index], end=&#34;\r&#34;, flush=True)
                                        pause = StartTime - int(time.time())
                                        while pause &lt;= 0.25 :
                                            print(&#34;到达签到时间！&#34;)
                                            self.nightAttendance() # 签到跳转
                                            return
                                        time.sleep(0.25)
            if Position[&#34;code&#34;] == 999:
                print(&#34;[*] 晚签信息获取失败\n[*] 有可能是校本化未授权或您的签到页面非本脚本所适配&#34;)
                self.authorization()
        return

    def nightAttendance(self): # 执行签到
        paramss = {
            &#34;Code&#34;: &#34;&#34;,
            &#34;PhoneModel&#34;: &#34;&#34;,
            &#34;SignInfo&#34;: &#39;{&#34;Reason&#34;:&#34;&#34;,&#34;AttachmentFileName&#34;:&#34;&#34;,&#34;LngLat&#34;:&#34;&#39; + self.lonss + &#39;,&#39; + self.latss + &#39;&#34;,&#34;Address&#34;:&#34;&#39; + self.Address + &#39;&#34;}&#39;,
            &#34;OutState&#34;: &#34;1&#34;
            }
        nightsign = requests.post(&#34;https://api.uyiban.com/nightAttendance/student/index/signIn?CSRF=&#34; + self.Attendancecookies[&#39;PHPSESSID&#39;], data=paramss, cookies={&#39;csrf_token&#39;: self.Attendancecookies[&#39;PHPSESSID&#39;], &#39;PHPSESSID&#39;: self.Attendancecookies[&#39;PHPSESSID&#39;]}, headers=self.HEADERS).json()
        print(&#34;签到返回数据:&#34;,nightsign)
        #print(nightsign)
        return self.signPosition() # 跳转回signPosition验证是否签到成功

    def loginin(self): # 登陆校验
        # 应当先判断列表账号是否都能正常登陆
        loginin = self.login() # 登录
        if loginin != 1:
            print(&#34;用户&#34;,loginin,&#34;登陆失败，请处理&#34;)
            print(&#34;按任意键退出脚本&#34;)
            ord(msvcrt.getch())
            sys.exit()
        self.authorization(0) # 校本化授权先执行
        return

    def setall(self): # 多人签到
        loginin = self.login() # 登录
        self.auth() # 授权
        self.signPosition() # 判断能否签到&amp;自动跳转签到
        #self.authorization(0) # 校本化授权 已写入
        return
def save_accounts(accounts):
    with open(&#34;accounts.txt&#34;, &#34;w&#34;) as f:
        for account in accounts:
            f.write(f&#34;{account.mobile},{account.password}\n&#34;)
def load_accounts():
    accounts = []
    if os.path.exists(&#34;accounts.txt&#34;):
        with open(&#34;accounts.txt&#34;, &#34;r&#34;) as f:
            for line in f:
                mobile, password = line.strip().split(&#39;,&#39;)
                accounts.append(yiban(mobile, password))
    return accounts
def display_accounts(accounts):
    print(&#34;当前账户列表:&#34;)
    for idx, account in enumerate(accounts, start=1):
        print(f&#34;{idx}. {account.mobile}&#34;)


def main():
    accounts, disturb_mode, disturb_count = load_accounts()
    if disturb_mode == &#39;on&#39; and disturb_count &gt; 0:
        print(&#34;免打扰模式开启，自动执行...&#34;)
        disturb_count -= 1
    else:
        action = &#39;继续&#39;
        while action.lower() == &#39;继续&#39;:
            display_accounts(accounts)
            choice = input(&#34;要修改或增加账号吗？(修改/增加/执行): &#34;)

            if choice.lower() == &#39;修改&#39;:
                index = int(input(&#34;请输入要修改的账号序号: &#34;)) - 1
                if 0 &lt;= index &lt; len(accounts):
                    new_mobile = input(&#34;输入新的手机号: &#34;)
                    new_password = input(&#34;输入新的密码: &#34;)
                    accounts[index] = yiban(new_mobile, new_password)
                    save_accounts(accounts, disturb_mode, disturb_count)
                    print(&#34;账户已更新&#34;)
            elif choice.lower() == &#39;增加&#39;:
                num_new_accounts = int(input(&#34;请输入要增加的账户数: &#34;))
                for _ in range(num_new_accounts):
                    mobile = input(&#34;请输入新手机号: &#34;)
                    password = input(&#34;请输入新密码: &#34;)
                    accounts.append(yiban(mobile, password))
                save_accounts(accounts, disturb_mode, disturb_count)
                print(&#34;新账户已添加&#34;)
            elif choice.lower() == &#39;执行&#39;:
                break

            action = input(&#34;是否继续修改或增加账户？(继续/执行): &#34;)

        if disturb_count == 0:  # 当不在免打扰模式或免打扰次数用完时询问
            disturb_mode = &#39;on&#39; if input(&#34;是否开启免打扰模式？(是/否): &#34;).lower() == &#39;是&#39; else &#39;off&#39;
            disturb_count = 7 if disturb_mode == &#39;on&#39; else 0

    save_accounts(accounts, disturb_mode, disturb_count)

    for account in accounts:
        account.loginin()
    time.sleep(0.5)
    print(&#34;#签到检查通过#################\n&#34;)
    for account in accounts:
        account.setall()
    time.sleep(0.1)
    print(&#34;##############################&#34;)
    print(&#34;签到任务已执行完成！&#34;)
    sys.exit()


if __name__ == &#34;__main__&#34;:
    main()
</code></pre><h1 id="一点点小改动">一点点小改动</h1>
<p>这个脚本有几处在Arch Linux上并不适用。</p>
<p>pip会往系统里面带脏东西，所以并不能直接执行pip install。会有如下报错：</p>
<pre tabindex="0"><code>pip install numpy
error: externally-managed-environment

× This environment is externally managed
╰─&gt; To install Python packages system-wide, try &#39;pacman -S
    python-xyz&#39;, where xyz is the package you are trying to
    install.
    
    If you wish to install a non-Arch-packaged Python package,
    create a virtual environment using &#39;python -m venv path/to/venv&#39;.
    Then use path/to/venv/bin/python and path/to/venv/bin/pip.
    
    If you wish to install a non-Arch packaged Python application,
    it may be easiest to use &#39;pipx install xyz&#39;, which will manage a
    virtual environment for you. Make sure you have python-pipx
    installed via pacman.

note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.
hint: See PEP 668 for the detailed specification.
</code></pre><p>最恰当的方法应该是给他来个虚拟环境。且msvcrt是一个Windows特定的模块，在Linux上不可用，可以代码里面直接给它扬了：</p>
<pre tabindex="0"><code>...# 上述代码照抄

def loginin(self): # 登陆校验
    # 应当先判断列表账号是否都能正常登陆
    loginin = self.login() # 登录
    if loginin != 1:
        print(&#34;用户&#34;,loginin,&#34;登陆失败，请处理&#34;)
        print(&#34;按任意键退出脚本&#34;)# 移除了msvcrt.getch()，因为在Linux上不可用
        input(&#34;按回车键退出脚本&#34;)
        sys.exit()
    self.authorization(0) # 校本化授权先执行
    return
    
...# 下面照抄
</code></pre><p>构建虚拟环境需要：</p>
<pre tabindex="0"><code>python3 -m venv /path/to/new/virtual/environment

source /path/to/new/virtual/environment/bin/activate

pip install requests numpy jsonpath

deactivate
</code></pre><p>在你的py文件目录下创建一个.sh：</p>
<pre tabindex="0"><code>#!/bin/bash

VENV_DIR=&#34;/path/to/your/venv&#34;

SCRIPT_PATH=&#34;/path/to/your/script.py&#34;

source &#34;$VENV_DIR/bin/activate&#34;

python &#34;$SCRIPT_PATH&#34;

deactivate

chmod +x /path/to/your/script.sh
/path/to/your/script.sh
</code></pre><p>然后就是考虑在Linux上如何进行定时任务的问题，经某位lockey朋友启发选择直接上大家所熟悉的cron：</p>
<pre tabindex="0"><code>sudo pacman -S cronie
sudo systemctl start cronie.service
sudo systemctl enable cronie.service

crontab -e # 转入nano编辑
0 0 * * * /path/to/your/script.sh # 自行照格式修改

#ctrl+o写入，enter，ctrl+x退出

crontab -l # 检查一下有没有写好
</code></pre><p><strong>DONE.</strong></p>
]]></content:encoded>
    </item>
    <item>
      <title>Smart car - freshman trash version</title>
      <link>http://localhost:1313/posts/tech/smart-car---freshman-trash-version/</link>
      <pubDate>Mon, 15 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/tech/smart-car---freshman-trash-version/</guid>
      <description>A good try for young</description>
      <content:encoded><![CDATA[<h1 id="这是什么">这是什么</h1>
<p>2024校EEA举办无人车的循迹避障赛。欣然规往。</p>
<p><img loading="lazy" src="https://img.nanimonai.org/map.jpg" alt="Map."  />
</p>
<h1 id="为什么去做这个">为什么去做这个</h1>
<p>兴趣啊，混蛋！难道还是为了什么生计什么未来什么饭碗而去的嘛？</p>
<h1 id="咋做的">咋做的</h1>
<p>刚开始和队友是有甚大的意淫的，企图先整个初号机出来，选方案就选了挺久，然后参考了很多用nano主控，车架也是上便宜的亚克力，循迹依靠pwm调值，随便整个五路红外循迹接个面包板在来三节电池代码写写就完事。二代机直接上PID然后再优化机械结构，换更好电机之类的。</p>
<p><img loading="lazy" src="https://img.nanimonai.org/choulou.png" alt=""  />
</p>
<p>事实上发现，这调试的东西也太多了。问题很多，情况非常多，是一开始所预想不到的。实现代码逻辑就得有不同的思路，前期兴致勃勃到，后期就是坚持就是成功，代码从开始的立志优化到最完美，到后来的能跑就行，一优化就又g了。不停的测试和排查故障是会令人烦躁的，例如：我误读要求以为要循迹两圈，然后抓耳挠腮写检测逻辑，最后基于队友原来代码写的是：</p>
<pre tabindex="0"><code>void loop() {
  if(digitalRead(Button) == 0){
    if (i &lt; 5){
      if(distance &gt;25){
        delay(10);
        xunxian();
      }
      else{
        bizhang();
      }
    }
    else{
      Motor(0, 0);
    }
  }
  else{
    Motor(0,0);
  }
}

...
xunxian()
...
else if (SL2 == 0 &amp;&amp; SL1 == 0 &amp;&amp; SR1 == 0 &amp;&amp; SR2 == 0 &amp;&amp; (SR3 == 0 || SL3 == 0)) {
    Motor(108+v,118+v);
    delay(10);
    i++;
  }
...
</code></pre><p>这样一坨我也不知道怎么形容的构思，直接给队友后面调车造成很大的困扰，虽然最后发现是电池电快无了，导致循迹都出现问题带不动电机转向。</p>
<p>尝试过五路红外和光电之后都不行，那个b传感器不稳定于是乎就有一堆的误判，然后就谜之操作。后来直接上了六路灰度直接爽飞，进入下一个阶段的debug。
<img loading="lazy" src="https://img.nanimonai.org/car.jpg" alt=""  />
</p>
<p>其实，笔者觉得不管是竞赛还是折腾东西，就是一个盛大的debug过程。世界就是一个巨大的草台班子。长期的游戏让我练就了被队友嬉笑怒骂不形于色的本领，我可以保证不首先使用言语攻击假想敌的家人，也保证不第一个给队友上压力。其次菜了得承认。最后，要有一颗折腾的心，这方面可能EOS教会我的更多一些，遇见不同种类，不同方式的问题刁难，有一些是很值得记录下来的，我以后也一定趁着自己还清醒要写文章记录一下。</p>
<p>这样看下来，折腾的那些便不足为奇了，本就是一直折腾的青春，我倒是不介意多学点多折腾点东西。最后是一拍脑袋想起来我还有电池，刚好能完赛没犯病。看下比赛可以看到很多还值得学的东西，pwm调速是肯定比不上pid的，然后机械结构的优化，比如某大跌在现场指出可以把传感器架设在中间，会有利于车的性能提升。可以参考到很多组不同的实现思路，这个比赛本身的意义就已经彰显，大学缺乏思维的相互碰撞和激发，当然大多数人是不经意间的，教会你东西的可能是一个话都讲不上几句的类陌生人。</p>
<p>然后我在反思，如果我失败了，一如我之前的些奇奇怪怪bug，有的时候tty都进不去，社区的方案也都尝试过了。失败了，我还会记录这些吗。答案很有可能是否，我会去自恃自己的记忆，而永远去逃避问题不了解其内容，也就是自身的进步仍然是基于一种脆弱的优越者假想甚至是自负论。还是不在tech里讨论自由意志和个人发展的孰优孰劣，多学多做就好。</p>
<p>（完篇的时候，时钟正好停在自己的十九岁生日的最后一分钟，很奇妙的体验，自己已经立下决心将所有节日以平常心看待，看淡生活的种种波澜，也不相信知天命的话术，但仍会下意识有所注意，感慨小时候那个一到生日就期盼着别人祝福的单纯的我，已经过去这么久了啊。静静地等待这一分钟流逝过去。经历自己变老真的是一件奇妙的事情啊，不过我也无悔去肆意地挥霍我的青春。）</p>
<p><strong>DONE.</strong></p>
]]></content:encoded>
    </item>
    <item>
      <title>WeCom check-in crack</title>
      <link>http://localhost:1313/posts/tech/wecom-check-in-crack/</link>
      <pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/tech/wecom-check-in-crack/</guid>
      <description>Out of time</description>
      <content:encoded><![CDATA[<h1 id="为什么研究这个">为什么研究这个</h1>
<p>学校在企业微信里面要求所有大学生在21:30-23:00期间进行打卡操作。鉴于企业微信的位置获取不是一般的抽象，除了查看你的GPS信号外还有调用附近的基站进行定位（西瓜和Mike 语），最为逆天的是本人的移动设备是哄蒙系统，也就无法享用诸多先进科技带来的便利。</p>
<p>因此，第一种方法应运而生：</p>
<ol>
<li>
<p>在手机上安装VMOS Pro，走虚拟机路线。其中的root和Xposed的模块安装均为傻瓜式操作，这里不过多赘述。BTW，虚拟安卓机在大学的另一大用途就是通过学习通考试。</p>
</li>
<li>
<p>安装应用变量，Fake location（fuck location的开发者在安卓10上测试过，但是VMOS Pro版本只有7.1和9，有兴趣者可以尝试一下能否可行），而且我们需要的是具有基站模拟功能的位置模拟软件。在当前诈骗猖獗的情况下自建伪基站是不切实且无异于找死的。Fake location需要爆米，我记得7r/月。</p>
</li>
<li>
<p>Xposed Installer后，激活应用变量，配置指定应用（如企业微信），其中比较重要的是你的安卓版本，IMEI和MEID这几个需要留意。如果你在之前的手机/母鸡上面打过卡了，这些就要原封不动的抄原来手机。反之则无所谓。</p>
</li>
<li>
<p>启动fake location。位置选择到位后启动模拟，同时启动基站模拟。</p>
</li>
</ol>
<p>PS：此法是由Mike和大西瓜研究而出。此法也有助于不同大学的上课打卡机制（我所了解的其他大学的打卡机制不是很严格），上班族的上班打卡机制。以及Fake location的路线模拟，可以帮助有需要者进行跑步的模拟。（导入运动软件进行操作云云），网络上面很多大佬也讲过类似操作，本人这样帮过朋友，证明其可行性。就是画路线的时候别超出操场或者撞墙里面了，以免露馅。</p>
<h1 id="好日子的结束">好日子的结束</h1>
<p>在一次美美不请假而出游的日子中，我意外发现第一种方法失效了。其具体表现为：地图识别我在A地（GPS），也就是目标打卡地，但是我的伪装被企业微信识破，即它能准确定位到我的真实所在地B地。而这个方案是在2023.12之前都有效的，且亲自实验过的。目前失败原因不明，有思路者欢迎联系我一起探讨。</p>
<p>后经排查原因无果后，高人OO指点采用第二种方法。</p>
<p>OO指出可以使用备用机装企业微信然后写自动脚本完成打卡，并且自己实验成功。</p>
<p>虽然说用的是老旧的备用机。但是仍然要注意自己的安全，隐私等。我最开始试验是在Hamibot上，Hamibot可以远程执行脚本，安全系数低。它算一个云端控制，理论上讲服务器后退可以看我手机的内容甚至控制，所以并不推荐这个平台。里面虽然有日志，但是服务器是外人的。开发文档里面有扫描文件，截屏，OCR获取信息。理论上能获取你手机的任何操作单仅限于显示时候，锁屏没有密码脚本的话，也是开不起来的。如果真要使用也建议是暂时使用几次，不需要使用的时候推荐关闭无障碍。</p>
<p>鄙人的脚本跑在一个叫OpenAuto.js的开源软件上<a href="https://github.com/openautojs/openautojs">(Github)</a>目前测试也是可行的，甚至优于Hamibot，因为其可以设置脚本的定时执行和循环执行，可以完成很多很多的其他操作而不用把这些内容加到脚本编写里面去。但还是要提供无障碍和一些权限，因此仍然建议找台备用机。</p>
<ol>
<li>
<p>设置无障碍，省电设置云云。</p>
</li>
<li>
<p>撰写并运行脚本。</p>
</li>
</ol>
<p>脚本编写可以参考<a href="https://github.com/hlsky1988/WeChatCheckingIn">(Github)</a>，他是写Hamibot上的脚本的，可以参考借鉴思路。</p>
<p>以下是我的打卡脚本，网络上有人说快捷打卡失误率较高，鄙人倒是没遇到过所以直接选择快捷打卡。这样进企业微信就行了，不用去完善导航到打卡栏再点击打卡的操作。</p>
<pre tabindex="0"><code>// 确保开启了Auto.js的无障碍服务
auto.waitFor();

// 唤醒并解锁设备（根据你的设备情况，这里可以自定义解锁逻辑）
device.wakeUp();
let { height, width } = device
let x = width / 2
let y1 = (height / 3) * 2
let y2 = height / 3
swipe(x, y1, x + 5, y2, 500)
sleep(3000)
toastLog(&#39;启动企业微信,准备打卡&#39;)


// 启动企业微信
app.launchPackage(&#34;com.tencent.wework&#34;);

//此时应该会自动完成打卡

// 结束脚本
exit();
</code></pre><p><strong>DONE.</strong></p>
]]></content:encoded>
    </item>
    <item>
      <title>舞文弄墨</title>
      <link>http://localhost:1313/posts/think/%E8%88%9E%E6%96%87%E5%BC%84%E5%A2%A8/</link>
      <pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/think/%E8%88%9E%E6%96%87%E5%BC%84%E5%A2%A8/</guid>
      <description>&lt;p&gt;  现代的青年愈发得迷失了。我也一样。所谓沉默，沉默的大多数。所谓嘈杂。一位看客，或许会好过突如其来的死亡吧。害怕失去害怕未知，害怕自己会对现实抱有期望&lt;/p&gt;
&lt;p&gt;听起来好像可笑的很。在一个青春中畏手畏脚，不敢做出承诺，也不怎么负责任。几年后回头看看，那会是庆幸还是懊悔？老者们责备，嘲笑年轻人的爱情，认为其只是源于欣赏，源于心理上虚假的自我幻想。青年人却嘲讽老者的“迂”，自以为能为另一半负起责任，能够互相包容。&lt;/p&gt;
&lt;p&gt;  好像都有些偏激。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;  仔细省察下来，自己亦无资格评头论足，有时候很想写一本自传体小说（像《在路上》那样）写下虚妄且矛盾的青春。你此时的不如意又有多重要，又有多少意义呢？积累成的只有经验。呵！又是经验，世故的思想，不再的初心。&lt;/p&gt;
&lt;p&gt;  一名茫然的探险者，是要深知真情流露之危险的。不妨带上一幅假笑的面具，默默收下“这个孩子/人性格真好/善良/听话”的类似夸耀。自己究竟是什么啊？我究竟又是怎样一个人？“面具戴得太久了，久而久之，就会粘在脸上，想要摘下来，除非伤筋动骨扒皮”&lt;/p&gt;
&lt;p&gt;  朋友以异样之眼光审视我正进行之写作，好像见到了什么不可理喻的东西。这纯粹是我浪费时间吧，我们是高三啊。有时我也这么认为，但还是要写点什么。感受到的真正的悲伤，会源自心底，怎么会像分数的小挫折。所谓悲伤，是心中只能掩盖不能化开的吧&lt;/p&gt;
&lt;p&gt;  所谓大苦难，所谓人生&lt;/p&gt;
&lt;p&gt;  阅读摘录：亲戚或余悲，他人亦已歌。死去何所道，托体同山阿。&lt;/p&gt;
&lt;p&gt;  中国人极善造神，造了再毁，毁了再造，乐此不疲。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>  现代的青年愈发得迷失了。我也一样。所谓沉默，沉默的大多数。所谓嘈杂。一位看客，或许会好过突如其来的死亡吧。害怕失去害怕未知，害怕自己会对现实抱有期望</p>
<p>听起来好像可笑的很。在一个青春中畏手畏脚，不敢做出承诺，也不怎么负责任。几年后回头看看，那会是庆幸还是懊悔？老者们责备，嘲笑年轻人的爱情，认为其只是源于欣赏，源于心理上虚假的自我幻想。青年人却嘲讽老者的“迂”，自以为能为另一半负起责任，能够互相包容。</p>
<p>  好像都有些偏激。</p>
<hr>
<p>  仔细省察下来，自己亦无资格评头论足，有时候很想写一本自传体小说（像《在路上》那样）写下虚妄且矛盾的青春。你此时的不如意又有多重要，又有多少意义呢？积累成的只有经验。呵！又是经验，世故的思想，不再的初心。</p>
<p>  一名茫然的探险者，是要深知真情流露之危险的。不妨带上一幅假笑的面具，默默收下“这个孩子/人性格真好/善良/听话”的类似夸耀。自己究竟是什么啊？我究竟又是怎样一个人？“面具戴得太久了，久而久之，就会粘在脸上，想要摘下来，除非伤筋动骨扒皮”</p>
<p>  朋友以异样之眼光审视我正进行之写作，好像见到了什么不可理喻的东西。这纯粹是我浪费时间吧，我们是高三啊。有时我也这么认为，但还是要写点什么。感受到的真正的悲伤，会源自心底，怎么会像分数的小挫折。所谓悲伤，是心中只能掩盖不能化开的吧</p>
<p>  所谓大苦难，所谓人生</p>
<p>  阅读摘录：亲戚或余悲，他人亦已歌。死去何所道，托体同山阿。</p>
<p>  中国人极善造神，造了再毁，毁了再造，乐此不疲。</p>
]]></content:encoded>
    </item>
    <item>
      <title>牢骚</title>
      <link>http://localhost:1313/posts/think/%E7%89%A2%E9%AA%9A/</link>
      <pubDate>Sat, 28 Oct 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/think/%E7%89%A2%E9%AA%9A/</guid>
      <description>&lt;p&gt;  找回了我用于记录往事的笔记本，近来手头的书也都还没读完，就权且写一些旧东西吧。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;20235&#34;&gt;2023.5&lt;/h1&gt;
&lt;p&gt;  思想总是跑在前面。他看得太远，比只能活在当下的身体还远得多。拿掉希望就是让思想重新回归身体，而且身体总有一天会腐烂。&lt;/p&gt;
&lt;h1 id=&#34;202310&#34;&gt;2023.10&lt;/h1&gt;
&lt;p&gt;  &amp;hellip;&lt;br&gt;
  我在散落的书堆间坐下，多少次反复关注父亲不安的的神态和言辞。那时候我又听到蝉鸣。那声音与前阵子所闻不同，已是寒蝉之鸣。我在夏天回到故乡，呆坐在沸腾似的蝉鸣之中，屡屡生出莫名的悲哀。我感觉我的哀愁总是同这蝉噪一起渗入心底。当此之时，我总是一动不动地独自凝视着自己。&lt;/p&gt;
&lt;p&gt;  我的哀愁在今夏归省后逐渐变换了情调。正如蝉声从蝉鸣变成寒蝉一般，我觉得周遭之人的命运也仿佛在巨大的轮回中渐次变动&lt;br&gt;
  &amp;hellip;&lt;/p&gt;
&lt;p&gt;———夏目漱石《心》&lt;/p&gt;
&lt;h1 id=&#34;回忆&#34;&gt;回忆&lt;/h1&gt;
&lt;p&gt;  我有写日记的习惯是初中伊始的，一位对我有非常大影响的语文老师建议我每天写一点文字，不管是记录或是描写，对写作是很有帮助的。&lt;/p&gt;
&lt;p&gt;  我听从了，原先觉得写无可写，是一件挺烦人的事情。比起自己发牢骚，我更喜欢看别人发，也就是看书。不知怎的，书越看约多，人也越来越愚钝，想得东西也越来越多，脑子里充斥着声音。那就都写着吧。&lt;/p&gt;
&lt;p&gt;  看得东西可能多了一点，自己也变得奇怪起来了，没有以前那种乐观与兴奋感了。感受最深刻的就是共鸣，我现实经历的事情在书中出现，或者是书中的事情投射到现实。震惊之余也只好长出一口气，鼓起勇气面对明天。&lt;/p&gt;
&lt;p&gt;  神性的解放，人性的回归。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>  找回了我用于记录往事的笔记本，近来手头的书也都还没读完，就权且写一些旧东西吧。</p>
<hr>
<h1 id="20235">2023.5</h1>
<p>  思想总是跑在前面。他看得太远，比只能活在当下的身体还远得多。拿掉希望就是让思想重新回归身体，而且身体总有一天会腐烂。</p>
<h1 id="202310">2023.10</h1>
<p>  &hellip;<br>
  我在散落的书堆间坐下，多少次反复关注父亲不安的的神态和言辞。那时候我又听到蝉鸣。那声音与前阵子所闻不同，已是寒蝉之鸣。我在夏天回到故乡，呆坐在沸腾似的蝉鸣之中，屡屡生出莫名的悲哀。我感觉我的哀愁总是同这蝉噪一起渗入心底。当此之时，我总是一动不动地独自凝视着自己。</p>
<p>  我的哀愁在今夏归省后逐渐变换了情调。正如蝉声从蝉鸣变成寒蝉一般，我觉得周遭之人的命运也仿佛在巨大的轮回中渐次变动<br>
  &hellip;</p>
<p>———夏目漱石《心》</p>
<h1 id="回忆">回忆</h1>
<p>  我有写日记的习惯是初中伊始的，一位对我有非常大影响的语文老师建议我每天写一点文字，不管是记录或是描写，对写作是很有帮助的。</p>
<p>  我听从了，原先觉得写无可写，是一件挺烦人的事情。比起自己发牢骚，我更喜欢看别人发，也就是看书。不知怎的，书越看约多，人也越来越愚钝，想得东西也越来越多，脑子里充斥着声音。那就都写着吧。</p>
<p>  看得东西可能多了一点，自己也变得奇怪起来了，没有以前那种乐观与兴奋感了。感受最深刻的就是共鸣，我现实经历的事情在书中出现，或者是书中的事情投射到现实。震惊之余也只好长出一口气，鼓起勇气面对明天。</p>
<p>  神性的解放，人性的回归。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Blog Test</title>
      <link>http://localhost:1313/posts/think/blog-test/</link>
      <pubDate>Thu, 28 Sep 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/think/blog-test/</guid>
      <description>这是我的第一篇文章</description>
      <content:encoded><![CDATA[<p><strong>Hello,world!</strong></p>
<p>写下这些字时，我是一名迷茫的电脑小白，进入浩如烟海的赛博世界，越是走到深处越会觉得自己无知，觉得自己无从下手。</p>
<hr>
<p>先写些无用漂亮话吧：</p>
<ul>
<li>
<h2 id="鲁镇社戏">2023.7.20<br>
看到的，全是更悲惨的戏文，更绝望的独白，更无助的祈求，更冷漠的看客<br>
————《鲁镇社戏》</h2>
</li>
<li>
<h2 id="也能把一切崇高的理想化作虚无">2023.8.21<br>
解构是一把双刃剑<br>
它能把所有顽固的糟粕变成乐子<br>
也能把一切崇高的理想化作虚无</h2>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Link</title>
      <link>http://localhost:1313/link/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/link/</guid>
      <description>何必使用火刑具呢？他人，即地狱。</description>
      <content:encoded><![CDATA[<a target="_blank" href=https://blog.iceyear.eu.org title=Ice&#32;Year class="friendurl">
  <div class="frienddiv">
    <div class="frienddivleft">
      <img class="myfriend" src=https://blog.iceyear.eu.org/android-chrome-512x512.webp />
    </div>
    <div class="frienddivright">
      <div class="friendname">Ice Year</div>
      <div class="friendinfo">Il n’y a pas de hasard, il n’y a que des rendez-vous.</div>
    </div>
  </div>
</a>
<a target="_blank" href=https://blog.yon.im/ title=Yon&#32;Zilch class="friendurl">
  <div class="frienddiv">
    <div class="frienddivleft">
      <img class="myfriend" src=https://static.yon.im/image/avatar.webp />
    </div>
    <div class="frienddivright">
      <div class="friendname">Yon Zilch</div>
      <div class="friendinfo">来自彼岸，归于虚无。浮华人生，黄粱一梦。</div>
    </div>
  </div>
</a>
<a target="_blank" href=https://blog.0pt.icu/ title=春风少年兄 class="friendurl">
  <div class="frienddiv">
    <div class="frienddivleft">
      <img class="myfriend" src=https://img.0pt.icu/blogbuilt/avatar.webp />
    </div>
    <div class="frienddivright">
      <div class="friendname">春风少年兄</div>
      <div class="friendinfo">你在世纪大道东门</div>
    </div>
  </div>
</a>
<a target="_blank" href=https://blog.dich.bid/ title=Dich class="friendurl">
  <div class="frienddiv">
    <div class="frienddivleft">
      <img class="myfriend" src=ZgotmplZ />
    </div>
    <div class="frienddivright">
      <div class="friendname">Dich</div>
      <div class="friendinfo">用电子罗盘，转赛博核桃，勘电磁风水，寻网络龙脉</div>
    </div>
  </div>
</a>
<a target="_blank" href=https://journal.milvoid.com/ title=milvoid class="friendurl">
  <div class="frienddiv">
    <div class="frienddivleft">
      <img class="myfriend" src=https://bed.4everland.store/2.png />
    </div>
    <div class="frienddivright">
      <div class="friendname">milvoid</div>
      <div class="friendinfo">Welcome to Milvoid’s Journal!</div>
    </div>
  </div>
</a>
<a target="_blank" href=https://doosam.uk/ title=sdy_zjx class="friendurl">
  <div class="frienddiv">
    <div class="frienddivleft">
      <img class="myfriend" src=https://avatars.githubusercontent.com/u/21271728?v&#61;4 />
    </div>
    <div class="frienddivright">
      <div class="friendname">sdy_zjx</div>
      <div class="friendinfo">可爱的学姐</div>
    </div>
  </div>
</a>
<a target="_blank" href=https://jinmaoquan12.github.io/bopmomio/ title=金毛犬 class="friendurl">
  <div class="frienddiv">
    <div class="frienddivleft">
      <img class="myfriend" src=https://telegraph-image-bhn.pages.dev/file/6707609445463b6fbe045.png />
    </div>
    <div class="frienddivright">
      <div class="friendname">金毛犬</div>
      <div class="friendinfo">可爱的学妹</div>
    </div>
  </div>
</a>
<a target="_blank" href=https://blog.watermeko.icu/ title=watermeko class="friendurl">
  <div class="frienddiv">
    <div class="frienddivleft">
      <img class="myfriend" src=https://image.watermeko.icu/file/3214b050c8da098f6b0c2.jpg />
    </div>
    <div class="frienddivright">
      <div class="friendname">watermeko</div>
      <div class="friendinfo"></div>
    </div>
  </div>
</a>
]]></content:encoded>
    </item>
    <item>
      <title>关于</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/about/</guid>
      <description>&lt;p&gt;我是一个爱打游戏的小屁孩，目前正在努力学习跟上大人们的步伐，却又畏惧于大人们世界的惊涛骇浪，可能是我还没有准备好去经受苦难。&lt;/p&gt;
&lt;p&gt;本项目由 &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; 生成&lt;/p&gt;
&lt;p&gt;主题 &lt;a href=&#34;https://github.com/adityatelange/hugo-Paper&#34;&gt;Paper&lt;/a&gt; 由 &lt;a href=&#34;https://github.com/adityatelange&#34;&gt;adityatelange&lt;/a&gt; 开发&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>我是一个爱打游戏的小屁孩，目前正在努力学习跟上大人们的步伐，却又畏惧于大人们世界的惊涛骇浪，可能是我还没有准备好去经受苦难。</p>
<p>本项目由 <a href="https://gohugo.io/">Hugo</a> 生成</p>
<p>主题 <a href="https://github.com/adityatelange/hugo-Paper">Paper</a> 由 <a href="https://github.com/adityatelange">adityatelange</a> 开发</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
