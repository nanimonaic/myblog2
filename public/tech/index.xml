<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>技术 on nanimonai&#39;s Blog</title>
    <link>https://blog.nanimonai.org/tech/</link>
    <description>Recent content in 技术 on nanimonai&#39;s Blog</description>
    <generator>Hugo -- 0.124.1</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 15 Apr 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://blog.nanimonai.org/tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Smart car - freshman trash version</title>
      <link>https://blog.nanimonai.org/posts/tech/smart-car---freshman-trash-version/</link>
      <pubDate>Mon, 15 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.nanimonai.org/posts/tech/smart-car---freshman-trash-version/</guid>
      <description>这是什么 2024校EEA举办无人车的循迹避障赛。欣然规往。
为什么去做这个 兴趣啊，混蛋！难道还是为了什么生计什么未来什么饭碗而去的嘛？
咋做的 刚开始和队友是有甚大的意淫的，企图先整个初号机出来，选方案就选了挺久，然后参考了很多，车架也是上便宜点的亚克力，循迹依靠pwm调值，随便整个五路红外循迹接个面包板在来三节电池代码写写就完事。二代机直接上PID然后再优化机械结构，换更好电机之类的。
事实上发现，这调试的东西也太多了。实现代码逻辑就得有不同的思路，前期兴致勃勃到了后期就是坚持为王，能坚持就是成功，代码从开始的立志优化到最完美，到后来的能跑就行，一优化就又g了。不停的测试和排查故障是会令人烦躁的，例如：我误读要求以为要循迹两圈，然后抓耳挠腮写检测逻辑，最后基于队友原来代码些写的是：
void loop() { if(digitalRead(Button) == 0){ if (i &amp;lt; 5){ if(distance &amp;gt;25){ delay(10); xunxian(); } else{ bizhang(); } } else{ Motor(0, 0); } } else{ Motor(0,0); } } ... xunxian() ... else if (SL2 == 0 &amp;amp;&amp;amp; SL1 == 0 &amp;amp;&amp;amp; SR1 == 0 &amp;amp;&amp;amp; SR2 == 0 &amp;amp;&amp;amp; (SR3 == 0 || SL3 == 0)) { Motor(108+v,118+v); delay(10); i++; } ... 这样一坨我也不知道怎么形容的构思，直接给队友后面调车造成很大的困扰，虽然最后发现是电池电不够了。但是在一个无力的情况下只能去改变当时所能改变的东西，还是很无力的。</description>
      <content:encoded><![CDATA[<h1 id="这是什么">这是什么</h1>
<p>2024校EEA举办无人车的循迹避障赛。欣然规往。</p>
<p><img loading="lazy" src="https://img.nanimonai.org/map.jpg" alt="Map."  />
</p>
<h1 id="为什么去做这个">为什么去做这个</h1>
<p>兴趣啊，混蛋！难道还是为了什么生计什么未来什么饭碗而去的嘛？</p>
<h1 id="咋做的">咋做的</h1>
<p>刚开始和队友是有甚大的意淫的，企图先整个初号机出来，选方案就选了挺久，然后参考了很多，车架也是上便宜点的亚克力，循迹依靠pwm调值，随便整个五路红外循迹接个面包板在来三节电池代码写写就完事。二代机直接上PID然后再优化机械结构，换更好电机之类的。</p>
<p><img loading="lazy" src="https://img.nanimonai.org/choulou.jpg" alt=""  />
</p>
<p>事实上发现，这调试的东西也太多了。实现代码逻辑就得有不同的思路，前期兴致勃勃到了后期就是坚持为王，能坚持就是成功，代码从开始的立志优化到最完美，到后来的能跑就行，一优化就又g了。不停的测试和排查故障是会令人烦躁的，例如：我误读要求以为要循迹两圈，然后抓耳挠腮写检测逻辑，最后基于队友原来代码些写的是：</p>
<pre tabindex="0"><code>void loop() {
  if(digitalRead(Button) == 0){
    if (i &lt; 5){
      if(distance &gt;25){
        delay(10);
        xunxian();
      }
      else{
        bizhang();
      }
    }
    else{
      Motor(0, 0);
    }
  }
  else{
    Motor(0,0);
  }
}

...
xunxian()
...
else if (SL2 == 0 &amp;&amp; SL1 == 0 &amp;&amp; SR1 == 0 &amp;&amp; SR2 == 0 &amp;&amp; (SR3 == 0 || SL3 == 0)) {
    Motor(108+v,118+v);
    delay(10);
    i++;
  }
...
</code></pre><p>这样一坨我也不知道怎么形容的构思，直接给队友后面调车造成很大的困扰，虽然最后发现是电池电不够了。但是在一个无力的情况下只能去改变当时所能改变的东西，还是很无力的。</p>
<p>也有那种不知道要怎么改的问题，尝试过五路红外和光电之后都不行，那个b传感器不稳定于是乎就有一堆的误判，然后就谜之操作。后来直接上了六路灰度直接爽飞，进入下一个阶段的debug。<br>
<img loading="lazy" src="https://img.nanimonai.org/car.jpg" alt=""  />
</p>
<p>其实，笔者觉得不管是竞赛还是折腾东西，就是一个盛大的debug过程。世界就是一个巨大的草台班子，你要有一定的抗压能力和纠错能力，再加以一定的细心和系统的学习。这个东西笔者恰好有一点点，长期的游戏生活让我练就了被队友嬉笑怒骂不形于色的本领，我可以保证不首先使用言语攻击假想敌的家人，也保证不第一个给队友上压力。其次菜了得承认，队友骂我如果我是真的菜我得道歉，这可以挽回一点点队友的游戏体验。最后，要有一颗折腾的心，这方面可能EOS教会我的更多一些，我遇见了不同种类，不同方式的问题刁难，有一些是很值得记录下来的，我以后也一定趁着自己还清醒要写文章记录一下，说不定还能帮到相同情况（即使概率很小）的同志。西瓜说的也很对啊，文章应为自己而著。</p>
<p>这样看下来，折腾的那些便不足为奇了，本就是一直折腾的青春，我倒是不介意多学点多折腾点东西。最后我也是一拍脑袋想起来我还有电池然后拿去，刚好能完赛，也很幸运没犯病，队友成就了我。看下比赛可以看到很多还值得学的东西，pwm调速是肯定比不上pid的，然后机械结构的优化，比如某大跌在现场指出可以把传感器架设在中间，会有利于车的性能提升。可以参考到很多组不同的实现思路，这个比赛本身的意义就已经彰显，大学最缺乏的就是思维的相互碰撞和激发，当然大多数人是不经意间的，教会你东西的可能是一个话都讲不上几句的类陌生人。</p>
<p>然后我在反思，如果我失败了，一如我之前的些奇奇怪怪bug，有的时候tty都进不去，社区的方案也都尝试过了。失败了，我还会记录这些吗。答案很有可能是否，我会去自恃自己的记忆，而永远去逃避问题不了解其内容，也就是自身的进步仍然是基于一种脆弱的优越者假想甚至是自负论。还是不在tech里讨论自由意志和个人发展的孰优孰劣，多学多做就好。</p>
<p>（完篇的时候，时钟正好停在自己的十九岁生日的最后一分钟，很奇妙的体验，自己已经立下决心将所有节日以平常心看待，看淡生活的种种波澜，也不相信知天命的话术，但仍会下意识有所注意，感慨小时候那个一到生日就期盼着别人祝福的单纯的我，已经过去这么久了啊。静静地等待这一分钟流逝过去。经历自己变老真的是一件奇妙的事情啊，不过也懒得再去开一篇新随想了，我无悔去肆意地挥霍我的青春。）</p>
<p><strong>DONE.</strong></p>
]]></content:encoded>
    </item>
    <item>
      <title>WeCom check-in crack</title>
      <link>https://blog.nanimonai.org/posts/tech/wecom-check-in-crack/</link>
      <pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://blog.nanimonai.org/posts/tech/wecom-check-in-crack/</guid>
      <description>为什么研究这个 学校在企业微信里面要求所有大学生在21:30-23:00期间进行打卡操作。鉴于企业微信的位置获取不是一般的抽象，除了查看你的GPS信号外还有调用附近的基站进行定位（西瓜和Mike 语），最为逆天的是本人的移动设备是哄蒙系统，也就无法享用诸多先进科技带来的便利。
因此，第一种方法应运而生：
在手机上安装VMOS Pro，走虚拟机路线。其中的root和Xposed的模块安装均为傻瓜式操作，这里不过多赘述。BTW，虚拟安卓机在大学的另一大用途就是通过学习通考试。
安装应用变量，Fake location（fuck location的开发者在安卓10上测试过，但是VMOS Pro版本只有7.1和9，有兴趣者可以尝试一下能否可行），而且我们需要的是具有基站模拟功能的位置模拟软件。在当前诈骗猖獗的情况下自建伪基站是不切实且无异于找死的。Fake location需要爆米，我记得7r/月。
Xposed Installer后，激活应用变量，配置指定应用（如企业微信），其中比较重要的是你的安卓版本，IMEI和MEID这几个需要留意。如果你在之前的手机/母鸡上面打过卡了，这些就要原封不动的抄原来手机。反之则无所谓。
启动fake location。位置选择到位后启动模拟，同时启动基站模拟。
PS：此法是由Mike和大西瓜研究而出。此法也有助于不同大学的上课打卡机制（我所了解的其他大学的打卡机制不是很严格），上班族的上班打卡机制。以及Fake location的路线模拟，可以帮助有需要者进行跑步的模拟。（导入运动软件进行操作云云），网络上面很多大佬也讲过类似操作，本人这样帮过朋友，证明其可行性。就是画路线的时候别超出操场或者撞墙里面了，以免露馅。
好日子的结束 在一次美美不请假而出游的日子中，我意外发现第一种方法失效了。其具体表现为：地图识别我在A地（GPS），也就是目标打卡地，但是我的伪装被企业微信识破，即它能准确定位到我的真实所在地B地。而这个方案是在2023.12之前都有效的，且亲自实验过的。目前失败原因不明，有思路者欢迎联系我一起探讨。
后经排查原因无果后，高人OO指点采用第二种方法。
OO指出可以使用备用机装企业微信然后写自动脚本完成打卡，并且自己实验成功。
虽然说用的是老旧的备用机。但是仍然要注意自己的安全，隐私等。我最开始试验是在Hamibot上，Hamibot可以远程执行脚本，安全系数低。它算一个云端控制，理论上讲服务器后退可以看我手机的内容甚至控制，所以并不推荐这个平台。里面虽然有日志，但是服务器是外人的。开发文档里面有扫描文件，截屏，OCR获取信息。理论上能获取你手机的任何操作单仅限于显示时候，锁屏没有密码脚本的话，也是开不起来的。如果真要使用也建议是暂时使用几次，不需要使用的时候推荐关闭无障碍。
鄙人的脚本跑在一个叫OpenAuto.js的开源软件上(Github)目前测试也是可行的，甚至优于Hamibot，因为其可以设置脚本的定时执行和循环执行，可以完成很多很多的其他操作而不用把这些内容加到脚本编写里面去。但还是要提供无障碍和一些权限，因此仍然建议找台备用机。
设置无障碍，省电设置云云。
撰写并运行脚本。
脚本编写可以参考(Github)，他是写Hamibot上的脚本的，可以参考借鉴思路。
以下是我的打卡脚本，网络上有人说快捷打卡失误率较高，鄙人倒是没遇到过所以直接选择快捷打卡。这样进企业微信就行了，不用去完善导航到打卡栏再点击打卡的操作。
// 确保开启了Auto.js的无障碍服务 auto.waitFor(); // 唤醒并解锁设备（根据你的设备情况，这里可以自定义解锁逻辑） device.wakeUp(); let { height, width } = device let x = width / 2 let y1 = (height / 3) * 2 let y2 = height / 3 swipe(x, y1, x + 5, y2, 500) sleep(3000) toastLog(&amp;#39;启动企业微信,准备打卡&amp;#39;) // 启动企业微信 app.</description>
      <content:encoded><![CDATA[<h1 id="为什么研究这个">为什么研究这个</h1>
<p>  学校在企业微信里面要求所有大学生在21:30-23:00期间进行打卡操作。鉴于企业微信的位置获取不是一般的抽象，除了查看你的GPS信号外还有调用附近的基站进行定位（西瓜和Mike 语），最为逆天的是本人的移动设备是哄蒙系统，也就无法享用诸多先进科技带来的便利。</p>
<p>  因此，第一种方法应运而生：</p>
<ol>
<li>
<p>在手机上安装VMOS Pro，走虚拟机路线。其中的root和Xposed的模块安装均为傻瓜式操作，这里不过多赘述。BTW，虚拟安卓机在大学的另一大用途就是通过学习通考试。</p>
</li>
<li>
<p>安装应用变量，Fake location（fuck location的开发者在安卓10上测试过，但是VMOS Pro版本只有7.1和9，有兴趣者可以尝试一下能否可行），而且我们需要的是具有基站模拟功能的位置模拟软件。在当前诈骗猖獗的情况下自建伪基站是不切实且无异于找死的。Fake location需要爆米，我记得7r/月。</p>
</li>
<li>
<p>Xposed Installer后，激活应用变量，配置指定应用（如企业微信），其中比较重要的是你的安卓版本，IMEI和MEID这几个需要留意。如果你在之前的手机/母鸡上面打过卡了，这些就要原封不动的抄原来手机。反之则无所谓。</p>
</li>
<li>
<p>启动fake location。位置选择到位后启动模拟，同时启动基站模拟。</p>
</li>
</ol>
<p>  PS：此法是由Mike和大西瓜研究而出。此法也有助于不同大学的上课打卡机制（我所了解的其他大学的打卡机制不是很严格），上班族的上班打卡机制。以及Fake location的路线模拟，可以帮助有需要者进行跑步的模拟。（导入运动软件进行操作云云），网络上面很多大佬也讲过类似操作，本人这样帮过朋友，证明其可行性。就是画路线的时候别超出操场或者撞墙里面了，以免露馅。</p>
<h1 id="好日子的结束">好日子的结束</h1>
<p>  在一次美美不请假而出游的日子中，我意外发现第一种方法失效了。其具体表现为：地图识别我在A地（GPS），也就是目标打卡地，但是我的伪装被企业微信识破，即它能准确定位到我的真实所在地B地。而这个方案是在2023.12之前都有效的，且亲自实验过的。目前失败原因不明，有思路者欢迎联系我一起探讨。</p>
<p>  后经排查原因无果后，高人OO指点采用第二种方法。</p>
<p>  OO指出可以使用备用机装企业微信然后写自动脚本完成打卡，并且自己实验成功。</p>
<p>  虽然说用的是老旧的备用机。但是仍然要注意自己的安全，隐私等。我最开始试验是在Hamibot上，Hamibot可以远程执行脚本，安全系数低。它算一个云端控制，理论上讲服务器后退可以看我手机的内容甚至控制，所以并不推荐这个平台。里面虽然有日志，但是服务器是外人的。开发文档里面有扫描文件，截屏，OCR获取信息。理论上能获取你手机的任何操作单仅限于显示时候，锁屏没有密码脚本的话，也是开不起来的。如果真要使用也建议是暂时使用几次，不需要使用的时候推荐关闭无障碍。</p>
<p>  鄙人的脚本跑在一个叫OpenAuto.js的开源软件上<a href="https://github.com/openautojs/openautojs">(Github)</a>目前测试也是可行的，甚至优于Hamibot，因为其可以设置脚本的定时执行和循环执行，可以完成很多很多的其他操作而不用把这些内容加到脚本编写里面去。但还是要提供无障碍和一些权限，因此仍然建议找台备用机。</p>
<ol>
<li>
<p>设置无障碍，省电设置云云。</p>
</li>
<li>
<p>撰写并运行脚本。</p>
</li>
</ol>
<p>  脚本编写可以参考<a href="https://github.com/hlsky1988/WeChatCheckingIn">(Github)</a>，他是写Hamibot上的脚本的，可以参考借鉴思路。</p>
<p>  以下是我的打卡脚本，网络上有人说快捷打卡失误率较高，鄙人倒是没遇到过所以直接选择快捷打卡。这样进企业微信就行了，不用去完善导航到打卡栏再点击打卡的操作。</p>
<pre tabindex="0"><code>// 确保开启了Auto.js的无障碍服务
auto.waitFor();

// 唤醒并解锁设备（根据你的设备情况，这里可以自定义解锁逻辑）
device.wakeUp();
let { height, width } = device
let x = width / 2
let y1 = (height / 3) * 2
let y2 = height / 3
swipe(x, y1, x + 5, y2, 500)
sleep(3000)
toastLog(&#39;启动企业微信,准备打卡&#39;)


// 启动企业微信
app.launchPackage(&#34;com.tencent.wework&#34;);

//此时应该会自动完成打卡

// 结束脚本
exit();
</code></pre><p><strong>DONE.</strong></p>
]]></content:encoded>
    </item>
  </channel>
</rss>
