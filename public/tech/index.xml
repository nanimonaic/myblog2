<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>技术 on nanimonai&#39;s Blog</title>
    <link>https://blog.nanimonai.org/tech/</link>
    <description>Recent content in 技术 on nanimonai&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 19 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.nanimonai.org/tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>BabyRSA</title>
      <link>https://blog.nanimonai.org/posts/tech/babyrsa/</link>
      <pubDate>Fri, 19 Apr 2024 00:00:00 +0000</pubDate>
      
      <guid>https://blog.nanimonai.org/posts/tech/babyrsa/</guid>
      <description>初试Crypto</description>
      <content:encoded><![CDATA[<h1 id="为什么研究这个">为什么研究这个</h1>
<p>我是🕊大王，本来4.6一比完就想写了，硬鸽到今天。主要也是因为一堆作业考试给应付得手忙脚乱的。</p>
<p>这个是我们校内的CTF中的一个题目名为“babyrsa”，下载下来之后是一个babyrsa.py，于是我试图认真地学一下rsa的知识。在《密码编码学与网络安全》这本书中指出：很多的公钥密码体制的理论都基于数论，如果读者接受本章中给出的结论，那么便不必严格地理解数论的有关知识。然而，要完全理解公钥算法，就需要理解这些数论知识。</p>
<p>然而，我对于数论的认知完全停留在初二那个暑假去学院数竞培训的时间，当时有一位老师专门讲到了数论，我第一次听到“模十同余”这个概念，也第一次接触到所谓的中国剩余定理（在当时我的注意力基本都被解析几何和四点公圆的奇葩题目给吸引住了）</p>
<h1 id="自使疑始释">自使疑始释</h1>
<p>回到主题，在公钥密码体制中基本由6个部分组成：</p>
<p><strong>明文</strong>：这是原始未加密的信息或数据，是加密过程的输入。</p>
<p><strong>加密算法</strong>：这是一系列用于将明文转换为密文的规则和步骤。在公钥加密中，这个过程利用了公钥。
公钥：这是一个数字证书，用于加密明文或验证签名，公开可获取。任何人都可以使用公钥来加密信息，但只有持有对应私钥的接收者能够解密。</p>
<p><strong>密文</strong>：经过加密算法处理后产生的加密过后的信息或数据，只有拥有相应私钥的人才能解密回明文。</p>
<p><strong>解密算法</strong>：这是一系列用于将密文转换回明文的规则和步骤。在公钥加密中，这个过程利用了私钥。</p>
<p><strong>私钥</strong>：这是一个数字证书，用于解密收到的信息或进行数字签名，应当被密切保护，不对外公开。私钥确保只有密钥的持有者才能解密那些用对应公钥加密的信息。</p>
<p>1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为&quot;Diffie-Hellman密钥交换算法&quot;。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。</p>
<p>这种新的加密模式被称为&quot;<strong>非对称加密算法</strong>&quot;。如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</p>
<p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。</p>
<p>（2）甲方获取乙方的公钥，然后用它对信息加密。</p>
<p>（3）乙方得到加密后的信息，用私钥解密。</p>
<p>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的&quot;非对称加密算法&quot;。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。</p>
<p>RSA是一种分组密码，其密文和明文都是0~n-1之间的证书，通常n是1024位的二进制数或309位的十进制数，也就是说n&lt;2^1024。明文分组进行加密，每个分组的二进制值均小于n。</p>
<p>（1）选定两个素数(p,q)（保密的，选定的）</p>
<p>（2）n=pq(公开的，计算得出的)</p>
<p>（3）e,满足gcd(φ(n),e)=1,1&lt;e&lt;φ(n)（公开的，选定的）</p>
<p>（4）d≡e^-1(mod φ(n))（保密的，计算得出的）</p>
<p>私钥为{d，n}，公钥为{e,n}。假设A公布了密钥，用户B要发送消息M给A，那么用户B只需要计算 M≡C^d(mod n)并发送给C；在接收端，用户A计算M≡C^d(mod n)以解出消息M。</p>
<p>需要注意的是，在rsa加密解密中都需要计算某个整数模n的整数次幂，如果先求整数的幂再模n，soleidei，中间的结果会非常大。可以运用模算术的性质解决，去简化为对中间的计算结果模n。因为在rsa中使用的指数很大，所以还得考虑幂运算的效率问题如果正常计算x^16次方，需要进行15次乘法，这样子的话对加密解密的时间就上了很大的压力。但是可以取重复每个部分结果的平方（2^2,2^4,2^8,2^16）,就只需要四次乘法了。</p>
<p>给出普遍的计算a^b mod n的算法，其中里面的变量c不是必须的，整数b表示为二进制数，引入它为了解释算法，c的终值即使指数值：</p>
<pre tabindex="0"><code>c←0;f←1
for i←k downto 0
	do c←2*c
	   f←(f*f) mod n
	if bi=1		（bi i是下标）
		then c←c+1
		  f←(f*a) mod n
	return f
</code></pre><p>我是懂哥，比赛看到这里假装自己懂了，然后开始看题目。后来我发现对于真正的rsa系列题目还有一系列难点涉及到e的取值（3，17，65537），各个情况的互相求解，不同的攻击方式等等，也要了解如中国剩余定理，费马定理，Miller-Rabin算法什么的，暂且按下不表。</p>
<h1 id="baby的rsa">Baby的rsa</h1>
<p>来看一下源码：</p>
<pre tabindex="0"><code>from gmpy2 import lcm
from Crypto.Util.number import getPrime, bytes_to_long

p = getPrime(1024)
q = getPrime(1024)
n = p*q
e = 54666
h = lcm(p - 1 , q - 1)
flag = b&#39;FCTF{***********}&#39;
m = bytes_to_long(flag)
c = pow(m, e, n)
print(&#39;n: &#39;, n)
print(&#39;h: &#39;, h)
print(&#39;c: &#39;, c)




&#39;&#39;&#39;
n:  25527104228224088488040470054859297799684430729586201999927539150044992353999083976287914924970569469434686168557247480896928199907052200737794107820101535432772515334456482673511185210116841919416618006696356771202410487435695207310741143088507315599413718818919895412368893805095614918899139207456629111515498628424508456173008212962396577655489900115537922862725514355690650346542020236913649627901430140820374812887483132677589636744805036428604336253688728768629554430310965303561197842773841768036265483485885167914975226451364872214945774294272151759555341126251417977165442601848916571897507614450138696307441
h:  3190888028528011061005058756857412224960553841198275249990942393755624044249885497035989365621321183679335771069655935112116024988381525092224263477512691929096564416807060334188898151264605239927077250837044596400301310929461900913842642886063414449926714852364986926546111725636951864862392400932078638939397162813314446093112008451870874459413340817966632865485406320788272316381137437957674310631802876313435533326327324210320100692584743680300917008843045504725648240011406960704841222641567549521400885041138306803979812904472944466100873729786606242613061006721938847831340052029664934674085291935568007804584
c:  13816656057233504242725466607519098922616296851282996573245636803888321169952138063011430581813327223855035775201965978271601144858474586480811825971179893352623779199435743915535990803704703901640138034283878850535619383284762202523145531803148037944606221169858890092284283768859214489478888725916054874525393017572123038563581085488781982829726844109883458439559508856073477596828594786184067989967020470472291721891068880110540699901476565507918536144452248311628215837448639176024403880919704090284307989085868140402906218076204485172179740170107661474514833980476371750724966421481356221210695767530318458804012
</code></pre><p>看起来非常吓人。</p>
<p>在这个位数的情况下，我不知道能不能把他分解，使用一些常规手段得等上好久，觉得可能没那么简单。</p>
<p>注意到，e = 54666，并不是一个素数。目前我们只知道e，h，c，n。我刚开始以为可以直接从h和n直接逆推出p和q，还是太天真了。然后去网络上找，发现有人讲过这种题型，但是讲的都有点奇怪，我当时没懂，又自己开始琢磨。在探索过程中，我发现一个名曰“欧几里得算法”的东西可能有所帮助，于是我去看了一下wiki，发现就是辗转相除法其实。</p>
<pre tabindex="0"><code>def gcd(a, b):
    while b != 0:
        t = a % b
        a = b
        b = t
    return a
</code></pre><p>想必这个迭代，各位都有印象，它广泛地出现在编程题目中。当然也有：</p>
<pre tabindex="0"><code>def gcd(a, b):
    return a if b == 0 else gcd(b, a % b)
</code></pre><p>扩展欧几里得算法是用于计算两个整数a和b的最大公约数以及满足贝祖等式ax+by=gcd(a,b)的整数解x和y的一种算法。</p>
<p>评价是有点汗流浃背了，我开局第一题做的这一题（一见钟情），到晚上都没想好是什么个思路。翻阅资料，了解到大素数和大整数的位数是尤为重要的，可以有奇淫巧技来破解。观察到n和h的位数相近，继续学习并尝试使用下列代码。</p>
<pre tabindex="0"><code>h = 
e = 
c = 
n = 

print(len(bin(h)[2:]))
print(len(bin(n)[2:]))

#bin(h)将变量 h 转换为二进制字符串表示；[2:]切片操作，从第三个字符（二进制数的起始字符）开始截取到末尾，去掉了前面的 &#39;0b&#39;，这是二进制数前缀；len()：获取字符串的长度，即二进制数的位数。
</code></pre><p>输出2045和2048。</p>
<p>n是两个大素数p和q的乘积。而h是p-1和q-1的最小公倍数。因此，它们的位数可以用来估计p和q的位数。具体地说，如果n是一个 2048 位的数字，那么p和q通常会是1024位的素数。</p>
<p>进行穷（ti）举（shen）攻击，进行遍历，差三位所以我选择（4，7）。这应该算是…穷举吧，试着当作φ的倍数去解，然后使用扩展欧几里得解密钥。其中，模逆是指对于给定的两个整数a和n，如果存在一个整数b，使得 ab≡1(mod n)，那么b就是a在模n意义下的乘法逆元，通常记作a−1。当然，≡表示模同余关系</p>
<p>复习一下上面的解密，其中M≡C^d(mod n)，d就是指数e的模φ的模逆，(e*d)%φ(n)=1 。需要指出的是，加密操作是指数运算，解密操作则是对密文进行模幂运算，其结果是明文的平方。因此，解密后的结果 m_2 是明文的平方。</p>
<p>最终代码如下：</p>
<pre tabindex="0"><code>import gmpy2
from Crypto.Util.number import *
h =
e =
c =
n =

#print(len(bin(h)[2:]))
#print(len(bin(n)[2:]))

for gcd_val in range(4, 8):
    phi = h * gcd_val
    try:
        d = gmpy2.invert(e // 2, phi)
        m_2 = pow(c, int(d), n)
        flag = long_to_bytes(gmpy2.isqrt(m_2))
        print(flag)
    except ZeroDivisionError:
        continue
</code></pre><p>可以得出 b&rsquo;FCTF{***********}&rsquo;（真实值是一串字符），提交即可。</p>
<p>这种题型算是比较基础的题目，当然让我学到很多，感觉很有意思。于是回到博客的开篇句：</p>
<p>“吾魂兮无求乎永生，竭尽兮人事之所能”
——Pindar</p>
<p><strong>DONE.</strong></p>
<p>参考文章<a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">(Sir,this way.)</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Research on the principle of automatic punch-in</title>
      <link>https://blog.nanimonai.org/posts/tech/research-on-the-principle-of-automatic-punch-in/</link>
      <pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate>
      
      <guid>https://blog.nanimonai.org/posts/tech/research-on-the-principle-of-automatic-punch-in/</guid>
      <description>应用</description>
      <content:encoded><![CDATA[<h1 id="这是什么">这是什么</h1>
<p>近日，打卡更新方式，由之前转移到了某一新平台上。求知欲驱使进行研究。写的不周，还请包含，同时我要非常感谢lockey中的一位热心朋友不厌其烦地为我指点迷津。</p>
<h1 id="如何实现">如何实现</h1>
<h2 id="第一步">第一步</h2>
<p>首先是获取签到的数据。不难看出，它采用rsa加密。</p>
<p><img loading="lazy" src="https://img.nanimonai.org/bunan.png" alt=""  />
</p>
<p>先去官网下载.apk文件，而众所周知，.apk是一种压缩文件，所以直接解压出来，find一下，确实是rsa，然后思考如何拿到公钥。</p>
<p>继续find寻找.pem，找到一个证书(本人搞到这里有点绷不住了，真的难绷），写py以还原出公钥：</p>
<p><img loading="lazy" src="https://img.nanimonai.org/pem.png" alt=""  />
</p>
<pre tabindex="0"><code>import OpenSSL.crypto

cert_text = &#34;&#34;&#34;
-----BEGIN CERTIFICATE-----
MIIFizCCA3OgAwIBAgIDAJY4MA0GCSqGSIb3DQEBCwUAMIGAMQswCQYDVQQGEwJD
TjEQMA4GA1UECAwHQmVpamluZzEMMAoGA1UECgwDTVNBMREwDwYDVQQLDAhPQUlE
X1NESzEeMBwGA1UEAwwVY29tLmJ1bi5taWl0bWRpZC5zaWduMR4wHAYJKoZIhvcN
AQkBFg9tc2FAY2FpY3QuYWMuY24wHhcNMjQwMTA3MTQ0ODU1WhcNMjUwMTA3MTQ0
ODU1WjB9MQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpamluZzEQMA4GA1UEBwwH
QmVpamluZzEQMA4GA1UECgwHd2phY2tlcjEWMBQGA1UEAwwNY29tLnlpYmFuLmFw
cDEgMB4GCSqGSIb3DQEJARYRd2FuZ2ppZTJAeWliYW4uY24wggIiMA0GCSqGSIb3
DQEBAQUAA4ICDwAwggIKAoICAQCyGC9T3GW4BSsvnVNqb8+HlnjJAQvTPd7H13m1
f945uUsUYYMaaZuICYjb4qefZUyQgyxBUTYfBOTpE7ccdcNoZgCp05RTng30zvkc
4pjawJIkNeIC2NGlN7RquO4Ka/06LSuq5N+bfL78E0MwZAinoxSswf/yNY5R1LJ2
b3I7BnW7rVSb7KbB0Q4z5KmuJ04hPVl7BtSdfVnvnRVTBDRm/cMgyupEl+CCGW8H
UejzPHdHeHRK1rx7fuwQI+5jgMmDYRNXZD4AmJ0vClurQR5avN2xOuxB8HbtB+lQ
itsNnQCvYY1Xp4s7FtfmT6JzDNQ//vRgXxYrOaVFfoY/ugrO+SfZtqej+mdKR3Kg
OaAA75t8zcJfM6WGrbPJl3xHc2bhD4kGwRkTAcHJ7WQOIrWz85CPCfIoYh8nZlBl
sCNamJJh6Pl2nAtmnfMtDuYZJo/2QK6J/KFtywsYIekU6fiRsJaaunBf5sD9Ixbv
JcRRB+HRCsySKYEg8z7Xlh90fHimfUgT0Gt44/o+nzPh7Cq9Ay6dWtMxYFx78Z1e
papOJdUNpZWIET8wQHriJmbJ18TlidGRAW85kW2ka2cr4u6Ed68JQa+nN+kbS0dD
euvOBGOsiqqCy5aeA0oz88HRWWIga02PLTZbEs4PdYrNzHWCISjnk34KpwwxYJUn
6Zpy1wIDAQABoxAwDjAMBgNVHRMBAf8EAjAAMA0GCSqGSIb3DQEBCwUAA4ICAQAk
o30meLI9Un/7KoUekSMhterJ6K11cHKAa+WQqqzp8If+gIhjsyYk7Wf1fgStvoNu
jILWSAfe2C2k74QrlVsUFXue2Ekc+eyDbUhwOi4rVju68/eu4HSpdIUbFQ7ZpivC
adjw7qfN90sp6S+O/dDQ9SzUPBpjMQQ6ZvSTFv7TtZ1cjzOpcfogrDGyOe+mE5Rv
xT3IaWFBcY2fe8lh+/7mJ27A5XgCka1LTZ2OFwI4d1gPWRhwi7R0p4rGhtmk2JJG
viz1rPn8pBBeR5zcwHFuDAbL/1C9d6rZ5lajycrdPZzbcuFAzx7NPafiMsyMYwBK
9oQDIjS5UmfMt+lMFk37yCesFqxq/DOIPm1Hz3N1t5RpcZuwIkCzXYhtOkCbu9SZ
xKqxztpcA5ySf3DWH4TIxKGXxIlC5pr2F4HsmKDIAO/1O6HXI0Bo+s/3KsDS/IMV
nlqKu1WUKUZJebjN/CL61ChfHjkmogslgTkQpJnGsWsix3v0nBFjpbOm/oXYYMJy
p+aMzppKaLx3mniXW/kimteNKu8EdeE7x/QeEIk5IUotfRPAeydVk9yqf+c4ClS9
YwVFAqIDzbC3nLBBXb36WNOoG+MFwWkjKoPhtIoLysTN1gNuFYUlJ1JptoP0Pe0I
k5FWnRRk1vKUktYUfMJE4PQg4sWxZhGkKrGU5zVLsg==
-----END CERTIFICATE-----
&#34;&#34;&#34;

cert=OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert_text)

public_key=OpenSSL.crypto.dump_publickey(OpenSSL.crypto.FILETYPE_PEM, cert.get_pubkey()).decode(&#34;utf-8&#34;)

print(public_key)
</code></pre><p>得出公钥就够用了：</p>
<p><img loading="lazy" src="https://img.nanimonai.org/rsa.png" alt=""  />
</p>
<h2 id="第二步">第二步</h2>
<p>获取cookie，参考github可得：</p>
<pre tabindex="0"><code>
def auth(self):
    COOKIES = {}
    CSRF = &#34;00000000000000000000000000000000&#34;
    HEADERS = {
        &#34;Origin&#34;: &#34;m.yiban.cn&#34;,
        &#34;origin&#34;:&#34;api.uyiban.com&#34;,
        &#34;origin&#34;:&#34;https://c.uyiban.com&#34;,
        &#34;authority&#34;: &#34;api.uyiban.com&#34;,
        &#34;AppVersion&#34;: &#34;5.0.17&#34;,
        &#34;x-requested-with&#34;: &#34;com.yiban.app&#34;,
        &#34;user-agent&#34;:&#34;Mozilla/5.0 (Linux; Android 12; XIAOMI Build/SKQ1.211006.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/112.0.5615.48 Mobile Safari/537.36;webank/h5face;webank/1.0 yiban_android/5.0.17&#34;
        }
    iapp = requests.get(&#34;http://f.yiban.cn/iapp/index?act=iapp7463&#34;, headers=HEADERS, allow_redirects=False, cookies=COOKIES) # 利用 loginToken 访问获取 verifyRequest跳转数据
    # 此处cookie带有 &#34;loginToken&#34; = “cdd6d4432743414c9e1faf3e792*****”
    act = iapp.headers[&#34;Location&#34;] # 返回302跳转目标
    verifyRequest = re.findall(r&#34;verify_request=(.*?)&amp;&#34;, act)[0] # 正则取302跳转目标，得到 verify_request 数据
    json = requests.get(&#34;https://api.uyiban.com/base/c/auth/yiban?verifyRequest=&#34; + verifyRequest + &#34;&amp;CSRF=&#34; + CSRF, headers=HEADERS, allow_redirects=False, cookies={&#39;csrf_token&#39;: CSRF})
    cookies = requests.utils.dict_from_cookiejar(json.cookies) # 获取cookie
    Attendancecookies = cookies # 签到cookies赋值self.Attendancecookies
    print(&#39;Location:&#39;,act,&#34;\n&#34;)
    print(&#39;cookies:&#39;,Attendancecookies,&#34;\n&#34;)
    
    ###打印数据：
    Location: https://c.uyiban.com/#/?verify_request=c9e814****53de92ccc&#39;, &#39;cpi&#39;: &#39;eyJD******%3D%3D&#39;, &#39;is_certified&#39;: &#39;1&#39;}    
    cookies: {&#39;PHPSESSID&#39;: &#39;fa1a28bc38cc**c4b1e87a8ce51f****&#39;, &#39;cpi&#39;: &#39;eyJDaG**%3D%3D&#39;, &#39;is_certified&#39;: &#39;1&#39;}
</code></pre><p>All right. 现在只需要PHPSESSID.</p>
<h2 id="第三步">第三步</h2>
<p>进行ADB调试，其中挺复杂的。我未来也要尝试一下有没有更加简单的调试方法。首先你PC得有Chrome，Firefox就不行。我Linux上面用的是Chromium。第一次尝试的时候移动端使用的是旧版本的Kiwi Browser，导致 chrome://inspect/#devices 这个界面没有inspect fallback选项。更新就行了。</p>
<p><img loading="lazy" src="https://img.nanimonai.org/404.png" alt=""  />
</p>
<p>在kiwi上找到Network Conditions，把用户代理叉掉并自定义写上MicroMessenger。</p>
<p><img loading="lazy" src="https://img.nanimonai.org/network.png" alt=""  />
</p>
<p>这个其实可以直接在控制台输入命令获取（忘记截图了，可以自己去试一下）：</p>
<pre tabindex="0"><code>console.log(&#34;User-Agent:&#34;, navigator.userAgent);
</code></pre><p>直接从中间几个开始分析（其实是依葫芦画瓢），能够成功找到https://api.uyiban.com/nightAttendance/student/index/signIn?CSRF=&hellip;</p>
<p>以及https://api.uyiban.com/nightAttendance/student/index/signPosition?CSRF=&hellip;</p>
<p>这样就可以进行测试，API 是 RESTful 标准。从登录开始追踪，使用curl去调试。</p>
<p><img loading="lazy" src="https://img.nanimonai.org/gongzuotai.png" alt=""  />

<img loading="lazy" src="https://img.nanimonai.org/yes.png" alt=""  />
</p>
<p>错误的都是{&lsquo;code&rsquo;: 500, &lsquo;msg&rsquo;: &lsquo;非法签到&rsquo;, &lsquo;data&rsquo;: None}	0.0</p>
<p>签到成功会返回{&lsquo;code&rsquo;: 0, &lsquo;msg&rsquo;: &lsquo;&rsquo;, &lsquo;data&rsquo;: True}</p>
<h2 id="第四步-前人的智慧">第四步 前人的智慧！</h2>
<p>脚本是大爱无私宽仁的Mike修改的，最初版是来自<a href="https://webcache.googleusercontent.com/search?q=cache:https%3A%2F%2Fwcyuns.cn%2Farchives%2F%25E6%2598%2593%25E7%258F%25AD%25E6%2599%259A%25E7%25AD%25BE%25E8%2584%259A%25E6%259C%25AC">this</a>思路也是借鉴于此，上面也算是重走一遍。真所谓巧夺天工，令人敬佩！</p>
<pre tabindex="0"><code>import json
import re
import sys
import os
import pickle
import time
import urllib
import jsonpath
from urllib import parse
import random
import requests
import numpy
import base64
import msvcrt
try:
    from Crypto.Cipher import PKCS1_v1_5
    from Crypto.PublicKey import RSA
except ModuleNotFoundError:
    print(&#34;缺少pycryptodome依赖！程序将尝试安装依赖！&#34;)
    os.system(&#34;pip3 install pycryptodome -i https://pypi.tuna.tsinghua.edu.cn/simple&#34;)
    os.execl(sys.executable, &#39;python3&#39;, __file__, *sys.argv)

def encryptPassword(pwd): # 登录密码加密
    # 密码加密
    PUBLIC_KEY = &#39;&#39;&#39;-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAzq0rgsM++ZxLRGHpdfre
Hu6UXhdlUS5P2WOxRG14qU8/iWSb/CkOqgOl8AGcOhlthkvolCdpUvVcVsVUxBv0
YRN0Jb64zPrn5aLVwQT4RJn5tXvoqLdHIXis7pljXAMDPVZOVlWJkDMk8YU6HDaA
MqsD6l5p9lg2LMP4OhMgaPX+CkO370LB5vRjJTHp03n+IqfxXoC7DEd+kxRIEM2C
EDgUSYDJBDgwBvGALZmvB/a1b0im9t1P/EmnuE7uN9NRFoWyVpOiEwo/Ti7rmJGf
qNT3vvtfWo4nXsm1rYQXsPayoKDSRaba3gFY/1SYWLAuSO2q2da5ZCcsAk5RKy0V
c1hUg8n6y0YLAvuzoXY5VyNMXkhH5Zc5Kg64b5RxILeZpZG0MV7GFY3sw//k7SNg
darKT8A0Iv3l3lfguX3HNi6dkf97kS/EiA0tbkIB/JNjv13mq8HL7LijRt2hkKqP
PhQW88xC/exZilU5pAavoZOPuZIOTUHqtpRq4ZeKl+wDf+e5lPYFDpihWGjplGpa
4BOSmGeo/SyVFPji9QF4Pk0DRJF/NjwJoAC60xHAVt5Z4gQSOOOjNZDCswA0ry2L
e8m5cv5vPGY75uVrGqALQ6Xm961PPc5cJ1q7tmEZMj+z5HE7tgAdhiPI6acKgrAv
+1k4N0OVqKamMS+PVpD05hUCAwEAAQ==
-----END PUBLIC KEY-----&#39;&#39;&#39;
    cipher = PKCS1_v1_5.new(RSA.importKey(PUBLIC_KEY))
    cipher_text = base64.b64encode(cipher.encrypt(bytes(pwd, encoding=&#34;utf8&#34;)))
    return cipher_text.decode(&#34;utf-8&#34;)
####################################################################################################################################################################################################
####################################################################################################################################################################################################

class yiban:
    COOKIES = {}
    def __init__(self, mobile, password): # 全局变量
        self.mobile = mobile # 登录手机号
        self.password = password # 登录密码
        self.session = requests.session()
        self.HEADERS = {
            &#34;Origin&#34;: &#34;m.yiban.cn&#34;,
            &#34;origin&#34;:&#34;api.uyiban.com&#34;,
            &#34;origin&#34;:&#34;https://c.uyiban.com&#34;,
            &#34;authority&#34;: &#34;api.uyiban.com&#34;,
            &#34;AppVersion&#34;: &#34;5.1.2&#34;,
            &#34;x-requested-with&#34;: &#34;com.yiban.app&#34;,
            &#34;user-agent&#34;:&#34;Mozilla/5.0 (Linux; Android 12; Redmi K30 Pro Build/SKQ1.211006.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/112.0.5615.48 Mobile Safari/537.36;webank/h5face;webank/1.0 yiban_android/5.0.17&#34;
            }
        self.Attendancecookies = {}
        self.CSRF = &#34;00000000000000000000000000000000&#34;

    def login(self): # 登录
        params = {
            &#34;mobile&#34;: self.mobile, #登录手机号
            &#34;password&#34;: encryptPassword(self.password), #RSA加密后的登录密码
            &#34;ct&#34;: &#34;2&#34;, #固定参数
            &#34;identify&#34;: &#34;0&#34;, #固定参数
        }
        # 配置登录数据
        response = requests.post(&#34;https://m.yiban.cn/api/v4/passport/login&#34;, data=params, allow_redirects=False, cookies=self.COOKIES, headers=self.HEADERS).json()
        if response is not None and response[&#34;response&#34;] == 100:
            self.access_token = response[&#34;data&#34;][&#34;access_token&#34;]
            self.HEADERS[&#34;Authorization&#34;] = &#34;Bearer &#34; + self.access_token
            # 增加cookie
            self.COOKIES[&#34;loginToken&#34;] = self.access_token
            print(&#39;用户信息:&#39;,response,&#34;\n&#34;)
            print(&#39;loginToken:&#39;,self.access_token,&#34;\n&#34;)
            print(&#39;用户姓名:&#39;,response[&#34;data&#34;][&#34;user&#34;][&#34;name&#34;],&#34;\n手机号码：&#34;,response[&#34;data&#34;][&#34;user&#34;][&#34;phone&#34;])
            return 1
        else:
            print(response)
            return self.mobile
        #返回https://f.yiban.cn/iapp/index?act=iapp7463所需的Cookie“loginToken=ce196e5fb2900bc35b44e1f1b4ed****”


        #通过获取的loginToken访问iapp后台得到值verifyRequest
        #利用verifyRequest访问api获取签到用的cookie
        #返回cookie内容范例
        #{&#39;PHPSESSID&#39;: &#39;1aef34b976315dca8400711255f1a9af&#39;, &#39;cpi&#39;: &#39;eyJDaGFubmVsIjoieWliYW......TliNWViZTUxYWMifQ%3D%3D&#39;, &#39;is_certified&#39;: &#39;1&#39;}
        #PHPSESSID为关键值，有这一个参数就可以访问签到等相关内容
        #cpi 使用base64编码 有个人相关信息
    def auth(self): # 获取签到cookie
        iapp = requests.get(&#34;http://f.yiban.cn/iapp/index?act=iapp7463&#34;, headers=self.HEADERS, allow_redirects=False, cookies=self.COOKIES) # 利用 loginToken 访问获取 verifyRequest
        act = iapp.headers[&#34;Location&#34;] # 返回302跳转目标
        verifyRequest = re.findall(r&#34;verify_request=(.*?)&amp;&#34;, act)[0] # 正则取302跳转目标，得到 verify_request 数据
        json = requests.get(&#34;https://api.uyiban.com/base/c/auth/yiban?verifyRequest=&#34; + verifyRequest + &#34;&amp;CSRF=&#34; + self.CSRF, headers=self.HEADERS, allow_redirects=False, cookies={&#39;csrf_token&#39;: self.CSRF})
        #访问api获取cookie CSRF值按此可用，只验证位数
        cookies = requests.utils.dict_from_cookiejar(json.cookies) # 获取cookie
        self.Attendancecookies = cookies # 签到cookies赋值self.Attendancecookies
        print(&#39;Location:&#39;,act,&#34;\n&#34;)
        print(&#39;cookies:&#39;,self.Attendancecookies,&#34;\n&#34;)
        return

    def authorization(self, testauth): # 授权校本化
        self.testauth = testauth
        authhtml = requests.get(&#34;https://oauth.yiban.cn/code/html?client_id=95626fa3080300ea&amp;redirect_uri=https://f.yiban.cn/iapp7463&#34;) # 利用 loginToken 访问获取 verifyRequest
        HTML_PUBLIC_KEY = re.search(&#39;&lt;input type=&#34;test&#34; id=&#34;key&#34; value=&#34;((?:.|\n)+)?&#34; style=&#34;display:none&#34;&gt;&#39;,authhtml.text)[1] # 获取网页签到加密 password 证书
        webcookies = requests.utils.dict_from_cookiejar(authhtml.cookies) # 获取校本化授权 cookie    登录需要
        print()
        print(&#34;获取的网页cookie:&#34;,webcookies)
        print(&#34;获取的网页加密证书:&#34;,HTML_PUBLIC_KEY,&#34;\n&#34;)
        HTML_cipher = PKCS1_v1_5.new(RSA.importKey(HTML_PUBLIC_KEY))
        HTML_cipher_text = base64.b64encode(HTML_cipher.encrypt(bytes(self.password, encoding=&#34;utf8&#34;)))
        HTML_cipher_decode = HTML_cipher_text.decode(&#34;utf-8&#34;)
        print(&#34;密码网页加密结果:&#34;,HTML_cipher_decode)
        webparams = {
            &#34;oauth_uname&#34;: self.mobile , # 账号
            &#34;oauth_upwd&#34;: HTML_cipher_decode , # 加密后密码
            &#34;client_id&#34;: &#34;95626fa3080300ea&#34;, # 应用端编号
            &#34;redirect_uri&#34;: &#34;http://f.yiban.cn/iapp7463&#34;, # 应用端回调地址
            }
        webauth = requests.post(&#34;https://oauth.yiban.cn/code/usersure&#34;, data=webparams, cookies=webcookies, headers=self.HEADERS).json()
        print(&#34;授权结果&#34;,webauth,&#34;\n&#34;)
        print(&#34;授权成功，返回获取签到信息中...&#34;)
        return

    def signPosition(self):
        Position = requests.get(&#34;https://api.uyiban.com/nightAttendance/student/index/signPosition?CSRF=&#34; + self.CSRF, allow_redirects=False, cookies={&#39;PHPSESSID&#39;: self.Attendancecookies[&#39;PHPSESSID&#39;], &#39;csrf_token&#39;: self.CSRF}, headers=self.HEADERS).json()
        if Position[&#34;code&#34;] == 0: # 判断是否登录成功
            print(&#34;校本化已授权，有晚签任务\n&#34;)
            print(&#34;可签到数据:&#34;,Position,&#34;\n&#34;)
            State=Position[&#34;data&#34;][&#34;State&#34;] # 获取状态码
            Msg=Position[&#34;data&#34;][&#34;Msg&#34;] # 获取返回信息
            StartTime=Position[&#34;data&#34;][&#34;Range&#34;][&#34;StartTime&#34;] # 获取签到开始时间
            self.StartTime =  StartTime
            EndTime=Position[&#34;data&#34;][&#34;Range&#34;][&#34;EndTime&#34;] # 获取签到结束时间
            pause = StartTime - int(time.time()) # 获取系统现在时间
            if State == 2: # 没有签到任务 如学校没有晚签
                print(&#34;您&#34;,Position[&#34;data&#34;][&#34;Msg&#34;])
                return
            else:
                if State == 3: # 已签到
                    print(&#34;[*] 签到接口返回数据：&#34;,Position[&#34;data&#34;][&#34;Msg&#34;])
                    return
                else:
                    self.Address=jsonpath.jsonpath(Position,&#39;$...Address&#39;)[0] # 获取可签到位置 地址
                    self.LngLat=jsonpath.jsonpath(Position,&#39;$...LngLat&#39;)[0] # 获取可签到位置 经纬度
                    self.lonss = &#39;%.6f&#39; %float(round(float(self.LngLat.split(&#34;,&#34;)[0]),3) + float(random.uniform(0.000100,0.000999))) # 根据地址随机修改经度后3位，达到每次定位位置不一样
                    self.latss = &#39;%.6f&#39; %float(round(float(self.LngLat.split(&#34;,&#34;)[1]),3) + float(random.uniform(0.000100,0.000999))) # 根据地址随机修改纬度后3位，达到每次定位位置不一样
                    if State == 0: # 已经到达签到时间
                        print(&#34;可以签到，立即执行！\n&#34;)
                        self.nightAttendance() # 签到跳转
                    else:
                        if State == 1: # 还未开始签到
                            pause = StartTime - int(time.time()) # 获取剩余时间
                            while pause &gt;= 60 :
                                list = [&#34;\\&#34;, &#34;|&#34;, &#34;/&#34;, &#34;—&#34;]
                                index = pause % 4
                                print(&#34;[*] 距签到时间还有 {} 秒 {}&#34;.format(pause,list[index]), end=&#34;\r&#34;, flush=True)
                                pause = StartTime - int(time.time())
                                time.sleep(1)
                            else:
                                while pause &lt;= 60 and pause &gt;=10 :
                                    print(&#34;[*] 距签到时间还有 {} 秒 {}&#34;.format(pause,list[index]), end=&#34;\r&#34;, flush=True)
                                    pause = StartTime - int(time.time())
                                    time.sleep(0.5)
                                else:
                                    while pause &lt;= 10 :
                                        print(&#34;[*] 距签到时间还有 {} 秒 {}&#34;).format(pause,list[index], end=&#34;\r&#34;, flush=True)
                                        pause = StartTime - int(time.time())
                                        while pause &lt;= 0.25 :
                                            print(&#34;到达签到时间！&#34;)
                                            self.nightAttendance() # 签到跳转
                                            return
                                        time.sleep(0.25)
            if Position[&#34;code&#34;] == 999:
                print(&#34;[*] 晚签信息获取失败\n[*] 有可能是校本化未授权或您的签到页面非本脚本所适配&#34;)
                self.authorization()
        return

    def nightAttendance(self): # 执行签到
        paramss = {
            &#34;Code&#34;: &#34;&#34;,
            &#34;PhoneModel&#34;: &#34;&#34;,
            &#34;SignInfo&#34;: &#39;{&#34;Reason&#34;:&#34;&#34;,&#34;AttachmentFileName&#34;:&#34;&#34;,&#34;LngLat&#34;:&#34;&#39; + self.lonss + &#39;,&#39; + self.latss + &#39;&#34;,&#34;Address&#34;:&#34;&#39; + self.Address + &#39;&#34;}&#39;,
            &#34;OutState&#34;: &#34;1&#34;
            }
        nightsign = requests.post(&#34;https://api.uyiban.com/nightAttendance/student/index/signIn?CSRF=&#34; + self.Attendancecookies[&#39;PHPSESSID&#39;], data=paramss, cookies={&#39;csrf_token&#39;: self.Attendancecookies[&#39;PHPSESSID&#39;], &#39;PHPSESSID&#39;: self.Attendancecookies[&#39;PHPSESSID&#39;]}, headers=self.HEADERS).json()
        print(&#34;签到返回数据:&#34;,nightsign)
        #print(nightsign)
        return self.signPosition() # 跳转回signPosition验证是否签到成功

    def loginin(self): # 登陆校验
        # 应当先判断列表账号是否都能正常登陆
        loginin = self.login() # 登录
        if loginin != 1:
            print(&#34;用户&#34;,loginin,&#34;登陆失败，请处理&#34;)
            print(&#34;按任意键退出脚本&#34;)
            ord(msvcrt.getch())
            sys.exit()
        self.authorization(0) # 校本化授权先执行
        return

    def setall(self): # 多人签到
        loginin = self.login() # 登录
        self.auth() # 授权
        self.signPosition() # 判断能否签到&amp;自动跳转签到
        #self.authorization(0) # 校本化授权 已写入
        return
def save_accounts(accounts):
    with open(&#34;accounts.txt&#34;, &#34;w&#34;) as f:
        for account in accounts:
            f.write(f&#34;{account.mobile},{account.password}\n&#34;)
def load_accounts():
    accounts = []
    if os.path.exists(&#34;accounts.txt&#34;):
        with open(&#34;accounts.txt&#34;, &#34;r&#34;) as f:
            for line in f:
                mobile, password = line.strip().split(&#39;,&#39;)
                accounts.append(yiban(mobile, password))
    return accounts
def display_accounts(accounts):
    print(&#34;当前账户列表:&#34;)
    for idx, account in enumerate(accounts, start=1):
        print(f&#34;{idx}. {account.mobile}&#34;)


def main():
    accounts = load_accounts()
    action = &#39;继续&#39;

    while action.lower() == &#39;继续&#39;:
        display_accounts(accounts)
        choice = input(&#34;要修改或增加账号吗？(修改/增加/执行): &#34;)

        if choice.lower() == &#39;修改&#39;:
            index = int(input(&#34;请输入要修改的账号序号: &#34;)) - 1
            if 0 &lt;= index &lt; len(accounts):
                new_mobile = input(&#34;输入新的手机号: &#34;)
                new_password = input(&#34;输入新的密码: &#34;)
                accounts[index] = yiban(new_mobile, new_password)
                save_accounts(accounts)
                print(&#34;账户已更新&#34;)
        elif choice.lower() == &#39;增加&#39;:
            num_new_accounts = int(input(&#34;请输入要增加的账户数: &#34;))
            for _ in range(num_new_accounts):
                mobile = input(&#34;请输入新手机号: &#34;)
                password = input(&#34;请输入新密码: &#34;)
                accounts.append(yiban(mobile, password))
            save_accounts(accounts)
            print(&#34;新账户已添加&#34;)
        elif choice.lower() == &#39;执行&#39;:
            break

        action = input(&#34;是否继续修改或增加账户？(继续/执行): &#34;)

    for account in accounts:
        account.loginin()
    time.sleep(0.5)
    print(&#34;#签到检查通过#################\n&#34;)
    for account in accounts:
        account.setall()
    time.sleep(0.1)
    print(&#34;##############################&#34;)
    print(&#34;签到任务已执行完成！&#34;)
    sys.exit()


if __name__ == &#34;__main__&#34;:
    main()
</code></pre><p><strong>DONE.</strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Smart car - freshman trash version</title>
      <link>https://blog.nanimonai.org/posts/tech/smart-car---freshman-trash-version/</link>
      <pubDate>Mon, 15 Apr 2024 00:00:00 +0000</pubDate>
      
      <guid>https://blog.nanimonai.org/posts/tech/smart-car---freshman-trash-version/</guid>
      <description>A good try for young</description>
      <content:encoded><![CDATA[<h1 id="这是什么">这是什么</h1>
<p>2024校EEA举办无人车的循迹避障赛。欣然规往。</p>
<p><img loading="lazy" src="https://img.nanimonai.org/map.jpg" alt="Map."  />
</p>
<h1 id="为什么去做这个">为什么去做这个</h1>
<p>兴趣啊，混蛋！难道还是为了什么生计什么未来什么饭碗而去的嘛？</p>
<h1 id="咋做的">咋做的</h1>
<p>刚开始和队友是有甚大的意淫的，企图先整个初号机出来，选方案就选了挺久，然后参考了很多用nano主控，车架也是上便宜的亚克力，循迹依靠pwm调值，随便整个五路红外循迹接个面包板在来三节电池代码写写就完事。二代机直接上PID然后再优化机械结构，换更好电机之类的。</p>
<p><img loading="lazy" src="https://img.nanimonai.org/choulou.png" alt=""  />
</p>
<p>事实上发现，这调试的东西也太多了。问题很多，情况非常多，是一开始所预想不到的。实现代码逻辑就得有不同的思路，前期兴致勃勃到，后期就是坚持就是成功，代码从开始的立志优化到最完美，到后来的能跑就行，一优化就又g了。不停的测试和排查故障是会令人烦躁的，例如：我误读要求以为要循迹两圈，然后抓耳挠腮写检测逻辑，最后基于队友原来代码写的是：</p>
<pre tabindex="0"><code>void loop() {
  if(digitalRead(Button) == 0){
    if (i &lt; 5){
      if(distance &gt;25){
        delay(10);
        xunxian();
      }
      else{
        bizhang();
      }
    }
    else{
      Motor(0, 0);
    }
  }
  else{
    Motor(0,0);
  }
}

...
xunxian()
...
else if (SL2 == 0 &amp;&amp; SL1 == 0 &amp;&amp; SR1 == 0 &amp;&amp; SR2 == 0 &amp;&amp; (SR3 == 0 || SL3 == 0)) {
    Motor(108+v,118+v);
    delay(10);
    i++;
  }
...
</code></pre><p>这样一坨我也不知道怎么形容的构思，直接给队友后面调车造成很大的困扰，虽然最后发现是电池电快无了，导致循迹都出现问题带不动电机转向。</p>
<p>尝试过五路红外和光电之后都不行，那个b传感器不稳定于是乎就有一堆的误判，然后就谜之操作。后来直接上了六路灰度直接爽飞，进入下一个阶段的debug。
<img loading="lazy" src="https://img.nanimonai.org/car.jpg" alt=""  />
</p>
<p>其实，笔者觉得不管是竞赛还是折腾东西，就是一个盛大的debug过程。世界就是一个巨大的草台班子。长期的游戏让我练就了被队友嬉笑怒骂不形于色的本领，我可以保证不首先使用言语攻击假想敌的家人，也保证不第一个给队友上压力。其次菜了得承认。最后，要有一颗折腾的心，这方面可能EOS教会我的更多一些，遇见不同种类，不同方式的问题刁难，有一些是很值得记录下来的，我以后也一定趁着自己还清醒要写文章记录一下。</p>
<p>这样看下来，折腾的那些便不足为奇了，本就是一直折腾的青春，我倒是不介意多学点多折腾点东西。最后是一拍脑袋想起来我还有电池，刚好能完赛没犯病。看下比赛可以看到很多还值得学的东西，pwm调速是肯定比不上pid的，然后机械结构的优化，比如某大跌在现场指出可以把传感器架设在中间，会有利于车的性能提升。可以参考到很多组不同的实现思路，这个比赛本身的意义就已经彰显，大学缺乏思维的相互碰撞和激发，当然大多数人是不经意间的，教会你东西的可能是一个话都讲不上几句的类陌生人。</p>
<p>然后我在反思，如果我失败了，一如我之前的些奇奇怪怪bug，有的时候tty都进不去，社区的方案也都尝试过了。失败了，我还会记录这些吗。答案很有可能是否，我会去自恃自己的记忆，而永远去逃避问题不了解其内容，也就是自身的进步仍然是基于一种脆弱的优越者假想甚至是自负论。还是不在tech里讨论自由意志和个人发展的孰优孰劣，多学多做就好。</p>
<p>（完篇的时候，时钟正好停在自己的十九岁生日的最后一分钟，很奇妙的体验，自己已经立下决心将所有节日以平常心看待，看淡生活的种种波澜，也不相信知天命的话术，但仍会下意识有所注意，感慨小时候那个一到生日就期盼着别人祝福的单纯的我，已经过去这么久了啊。静静地等待这一分钟流逝过去。经历自己变老真的是一件奇妙的事情啊，不过我也无悔去肆意地挥霍我的青春。）</p>
<p><strong>DONE.</strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>WeCom check-in crack</title>
      <link>https://blog.nanimonai.org/posts/tech/wecom-check-in-crack/</link>
      <pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://blog.nanimonai.org/posts/tech/wecom-check-in-crack/</guid>
      <description>Out of time</description>
      <content:encoded><![CDATA[<h1 id="为什么研究这个">为什么研究这个</h1>
<p>学校在企业微信里面要求所有大学生在21:30-23:00期间进行打卡操作。鉴于企业微信的位置获取不是一般的抽象，除了查看你的GPS信号外还有调用附近的基站进行定位（西瓜和Mike 语），最为逆天的是本人的移动设备是哄蒙系统，也就无法享用诸多先进科技带来的便利。</p>
<p>因此，第一种方法应运而生：</p>
<ol>
<li>
<p>在手机上安装VMOS Pro，走虚拟机路线。其中的root和Xposed的模块安装均为傻瓜式操作，这里不过多赘述。BTW，虚拟安卓机在大学的另一大用途就是通过学习通考试。</p>
</li>
<li>
<p>安装应用变量，Fake location（fuck location的开发者在安卓10上测试过，但是VMOS Pro版本只有7.1和9，有兴趣者可以尝试一下能否可行），而且我们需要的是具有基站模拟功能的位置模拟软件。在当前诈骗猖獗的情况下自建伪基站是不切实且无异于找死的。Fake location需要爆米，我记得7r/月。</p>
</li>
<li>
<p>Xposed Installer后，激活应用变量，配置指定应用（如企业微信），其中比较重要的是你的安卓版本，IMEI和MEID这几个需要留意。如果你在之前的手机/母鸡上面打过卡了，这些就要原封不动的抄原来手机。反之则无所谓。</p>
</li>
<li>
<p>启动fake location。位置选择到位后启动模拟，同时启动基站模拟。</p>
</li>
</ol>
<p>PS：此法是由Mike和大西瓜研究而出。此法也有助于不同大学的上课打卡机制（我所了解的其他大学的打卡机制不是很严格），上班族的上班打卡机制。以及Fake location的路线模拟，可以帮助有需要者进行跑步的模拟。（导入运动软件进行操作云云），网络上面很多大佬也讲过类似操作，本人这样帮过朋友，证明其可行性。就是画路线的时候别超出操场或者撞墙里面了，以免露馅。</p>
<h1 id="好日子的结束">好日子的结束</h1>
<p>在一次美美不请假而出游的日子中，我意外发现第一种方法失效了。其具体表现为：地图识别我在A地（GPS），也就是目标打卡地，但是我的伪装被企业微信识破，即它能准确定位到我的真实所在地B地。而这个方案是在2023.12之前都有效的，且亲自实验过的。目前失败原因不明，有思路者欢迎联系我一起探讨。</p>
<p>后经排查原因无果后，高人OO指点采用第二种方法。</p>
<p>OO指出可以使用备用机装企业微信然后写自动脚本完成打卡，并且自己实验成功。</p>
<p>虽然说用的是老旧的备用机。但是仍然要注意自己的安全，隐私等。我最开始试验是在Hamibot上，Hamibot可以远程执行脚本，安全系数低。它算一个云端控制，理论上讲服务器后退可以看我手机的内容甚至控制，所以并不推荐这个平台。里面虽然有日志，但是服务器是外人的。开发文档里面有扫描文件，截屏，OCR获取信息。理论上能获取你手机的任何操作单仅限于显示时候，锁屏没有密码脚本的话，也是开不起来的。如果真要使用也建议是暂时使用几次，不需要使用的时候推荐关闭无障碍。</p>
<p>鄙人的脚本跑在一个叫OpenAuto.js的开源软件上<a href="https://github.com/openautojs/openautojs">(Github)</a>目前测试也是可行的，甚至优于Hamibot，因为其可以设置脚本的定时执行和循环执行，可以完成很多很多的其他操作而不用把这些内容加到脚本编写里面去。但还是要提供无障碍和一些权限，因此仍然建议找台备用机。</p>
<ol>
<li>
<p>设置无障碍，省电设置云云。</p>
</li>
<li>
<p>撰写并运行脚本。</p>
</li>
</ol>
<p>脚本编写可以参考<a href="https://github.com/hlsky1988/WeChatCheckingIn">(Github)</a>，他是写Hamibot上的脚本的，可以参考借鉴思路。</p>
<p>以下是我的打卡脚本，网络上有人说快捷打卡失误率较高，鄙人倒是没遇到过所以直接选择快捷打卡。这样进企业微信就行了，不用去完善导航到打卡栏再点击打卡的操作。</p>
<pre tabindex="0"><code>// 确保开启了Auto.js的无障碍服务
auto.waitFor();

// 唤醒并解锁设备（根据你的设备情况，这里可以自定义解锁逻辑）
device.wakeUp();
let { height, width } = device
let x = width / 2
let y1 = (height / 3) * 2
let y2 = height / 3
swipe(x, y1, x + 5, y2, 500)
sleep(3000)
toastLog(&#39;启动企业微信,准备打卡&#39;)


// 启动企业微信
app.launchPackage(&#34;com.tencent.wework&#34;);

//此时应该会自动完成打卡

// 结束脚本
exit();
</code></pre><p><strong>DONE.</strong></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
