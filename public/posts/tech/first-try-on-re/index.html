<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>First try on RE | nanimonai's Blog</title>
<meta name=keywords content><meta name=description content="没有悲悯他的神明，命运倒向金钱的天平。"><meta name=author content="nanimonai"><link rel=canonical href=https://blog.nanimonai.org/posts/tech/first-try-on-re/><link crossorigin=anonymous href=/assets/css/stylesheet.0aa869c09b4b0cc7fb74b05914fa294a7d4bb5e5bcc7ac5a201534ce91321b93.css integrity="sha256-CqhpwJtLDMf7dLBZFPopSn1LteW8x6xaIBU0zpEyG5M=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://img.nanimonai.org/headimg.jpg><link rel=icon type=image/png sizes=16x16 href=https://img.nanimonai.org/headimg.jpg><link rel=icon type=image/png sizes=32x32 href=https://img.nanimonai.org/headimg.jpg><link rel=apple-touch-icon href=https://img.nanimonai.org/headimg.jpg><link rel=mask-icon href=https://img.nanimonai.org/headimg.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.nanimonai.org/posts/tech/first-try-on-re/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:title" content="First try on RE"><meta property="og:description" content="没有悲悯他的神明，命运倒向金钱的天平。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.nanimonai.org/posts/tech/first-try-on-re/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-10T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-10T00:00:00+00:00"><meta property="og:site_name" content="Neuromancer"><meta name=twitter:card content="summary"><meta name=twitter:title content="First try on RE"><meta name=twitter:description content="没有悲悯他的神明，命运倒向金钱的天平。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"技术","item":"https://blog.nanimonai.org/tech/"},{"@type":"ListItem","position":2,"name":"First try on RE","item":"https://blog.nanimonai.org/posts/tech/first-try-on-re/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"First try on RE","name":"First try on RE","description":"没有悲悯他的神明，命运倒向金钱的天平。","keywords":[],"articleBody":"第N次RE碰壁 ​\t近来参与尝试 BaseCTF 赛事中的“NEURO爱数学”题，结合官方WP进行总结。\n​\t题目共给出三项提示：\n1. flag为BaseCTF开头。z3可能存在多解，请尝试从数学角度解决。 2. 你知道的，11AdD8_result_21。 3. 多项式展开 ​\t下载下来是一个exe，选择拖入die。没什么问题：\n​\t再拖入ida端详。找到main后进入Pseduocode：\nint __fastcall main(int argc, const char **argv, const char **envp) { FILE *v3; // rax FILE *v4; // rax FILE *v5; // rax __int64 v6; // rdx char v9[26]; // [rsp+50h] [rbp-80h] BYREF _BYTE v10[26]; // [rsp+6Ah] [rbp-66h] BYREF int Src[7]; // [rsp+90h] [rbp-40h] BYREF unsigned __int8 v12; // [rsp+AFh] [rbp-21h] __int64 v13; // [rsp+B0h] [rbp-20h] _QWORD *v14; // [rsp+B8h] [rbp-18h] int m; // [rsp+C0h] [rbp-10h] int k; // [rsp+C4h] [rbp-Ch] int j; // [rsp+C8h] [rbp-8h] int i; // [rsp+CCh] [rbp-4h] _main(); feclearexcept(63); if ( fetestexcept(3) ) { puts(\"Floating point exceptions are set, possibly being debugged.\"); exit(1); } if ( IsDebuggerPresent() ) { puts(\"This program is being debugged. Exiting!\"); exit(1); } printf(\"I'm practicing my neuro math skills. Give me nine integers: \"); scanf( \"%d %d %d %d %d %d %d %d %d\", coeffs, \u0026dword_408044, \u0026dword_408048, \u0026dword_40804C, \u0026dword_408050, \u0026dword_408054, \u0026dword_408058, \u0026dword_40805C, \u0026dword_408060); printf(\"Hmm, let me think\"); v3 = __iob_func(); fflush(v3 + 1); if ( IsDebuggerPresent() ) { puts(\"This program is being debugged. Exiting!\"); exit(1); } putchar(46); v4 = __iob_func(); fflush(v4 + 1); putchar(46); v5 = __iob_func(); fflush(v5 + 1); puts(\".\"); for ( i = -60; i \u003c= 59; ++i ) { total = 0; power = 1; for ( j = 0; j \u003c= 8; ++j ) { total += power * coeffs[j]; power *= i; result = total; } if ( i == 44 || i == 58 || (::v12 = i + 37, (unsigned int)(i + 37) \u003c= 0x36) \u0026\u0026 (v14 = \u0026::v5, v13 = (unsigned int)::v12, v6 = ::v5, (v12 = _bittest64(\u0026v6, (unsigned int)::v12)) != 0) ) { if ( IsDebuggerPresent() ) { puts(\"This program is being debugged. Exiting!\"); exit(1); } if ( result ) goto LABEL_21; } else if ( !result ) { if ( IsDebuggerPresent() ) { puts(\"This program is being debugged. Exiting!\"); exit(1); } LABEL_21: puts(\"Those aren't the right numbers. Try again!\"); return 1; } } if ( dword_408060 != 1 ) { for ( k = 0; k \u003c= 8; ++k ) coeffs[k] /= dword_408060; } if ( IsDebuggerPresent() ) { puts(\"This program is being debugged. Exiting!\"); exit(1); } if ( dword_40805C == -80 \u0026\u0026 dword_408058 == -358 ) { printf(\"Correct! Here's the flag: \"); Src[0] = coeffs[0]; Src[1] = dword_408044; Src[2] = dword_408048; Src[3] = dword_40804C; LOWORD(Src[4]) = dword_408050; HIWORD(Src[4]) = dword_408054; LOWORD(Src[5]) = dword_408058; HIWORD(Src[5]) = dword_40805C; LOWORD(Src[6]) = dword_408060; memcpy(v9, Src, sizeof(v9)); memcpy(v10, Src, sizeof(v10)); for ( m = 0; m \u003c= 51; ++m ) { v9[m] ^= xorcode[m]; putchar((unsigned __int8)v9[m]); } putchar(10); return 0; } else { printf(\"WRONG\"); return 1; } } ​\t本质上是一个代码审计加逻辑复写，需要输入九个数。程序前半段大概是这样的公式：\n$$ x_1i^8 + x_2i^7 + x_3i^6 + x_4i^5 + x_5i^4 + x_6i^3 + x_7i^2 + x_8i^1 + x_9i^0 $$\n​\t而后是去计算(i-44)(i-58)(i-17)(i-6)(i-5)(i+4)(i+9)(i+37)————这个巨他妈难看，官方给出的答案是考虑本地模拟 or 动调。\n​\t程序要求用户输入9个整数，存储在 coeffs 数组中。使用这9个整数作为系数，构造一个8次多项式。然后在整数范围 [-60, 59] 内对这个多项式进行求值。对于每个 i 从 -60 到 59：初始化 total = 0 和 power = 1，对每个系数 j 从 0 到 8，然后：\ntotal += power * coeffs[j] power *= i ​\t最终的 total 就是多项式在 i 点的值。期间验证程序检查多项式在特定点的值是否为0。这些特定点上述以及概括而出。如果上述条件满足，程序会将所有系数除以最后一个系数（如果最后一个系数不等于1）。最终检查： 程序检查调整后的第8个系数是否等于-80，第7个系数是否等于-358。所有条件都满足，程序使用调整后的系数生成一个标志（flag）。生成过程涉及将系数转换为字节，然后与预定义的 xor code 进行异或解密。\n​\t以下是复现：\n#include #include int main(){ uint64_t v5 = 0x400C0210000001LL; // 模拟位数组 for(int x = -60; x \u003c= 60; x++){ if(x == 44 || x == 58){ printf(\"%d\\n\", x); continue; } unsigned int v12 = (unsigned int)(x + 37); if(v12 \u003c= 54 \u0026\u0026 (v5 \u0026 (1ULL \u003c\u003c v12))){ printf(\"%d\\n\", x); } } return 0; } ​\t将其展开与上面对比就可以知道x1-x9的数值：\nfrom sympy import symbols, expand x = symbols('x') polynomial = (x - 44) * (x - 58) * (x - 5) * (x + 37) * (x - 17) * (x + 9) * (x - 6) * (x + 4) expanded_polynomial = expand(polynomial) standard_form = expanded_polynomial.as_poly() coefficients = standard_form.all_coeffs() print(coefficients[::-1]) ​\t输出如下：\n​\t堂堂完结，代入即可得到flag。\n​\t（笔者注：使用cmd打开做，不然那个flag一闪就过去了。）\n​\t（事后看了师傅的直播，发现在coeffs这个地方ida里面，它九个整数的地址是连续的，所以可以直接右键改一下，看成一个数组就行）\n","wordCount":"624","inLanguage":"zh","datePublished":"2024-09-10T00:00:00Z","dateModified":"2024-09-10T00:00:00Z","author":[{"@type":"Person","name":"nanimonai"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.nanimonai.org/posts/tech/first-try-on-re/"},"publisher":{"@type":"Organization","name":"nanimonai's Blog","logo":{"@type":"ImageObject","url":"https://img.nanimonai.org/headimg.jpg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.nanimonai.org/ accesskey=h title="Neuromancer (Alt + H)"><img src=https://blog.nanimonai.org/apple-touch-icon.png alt aria-label=logo height=35>Neuromancer</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://blog.nanimonai.org/posts title=文章><span>文章</span></a></li><li><a href=https://blog.nanimonai.org/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.nanimonai.org/link title=友链><span>友链</span></a></li><li><a href=https://blog.nanimonai.org/about/ title=关于><span>关于</span></a></li><li><a href=https://blog.nanimonai.org/archives/ title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.nanimonai.org/>主页</a>&nbsp;»&nbsp;<a href=https://blog.nanimonai.org/tech/>技术</a></div><h1 class=post-title>First try on RE</h1><div class=post-description>没有悲悯他的神明，命运倒向金钱的天平。</div></header><div class=post-content><h1 id=第n次re碰壁>第N次RE碰壁<a hidden class=anchor aria-hidden=true href=#第n次re碰壁>#</a></h1><p>​ 近来参与尝试 BaseCTF 赛事中的“NEURO爱数学”题，结合官方WP进行总结。</p><p>​ 题目共给出三项提示：</p><pre><code>1. flag为BaseCTF开头。z3可能存在多解，请尝试从数学角度解决。
2. 你知道的，11AdD8_result_21。
3. 多项式展开
</code></pre><p>​ 下载下来是一个exe，选择拖入die。没什么问题：</p><p><img loading=lazy src=https://img.nanimonai.org/DIE.png alt></p><p>​ 再拖入ida端详。找到main后进入Pseduocode：</p><pre tabindex=0><code>int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  FILE *v5; // rax
  __int64 v6; // rdx
  char v9[26]; // [rsp+50h] [rbp-80h] BYREF
  _BYTE v10[26]; // [rsp+6Ah] [rbp-66h] BYREF
  int Src[7]; // [rsp+90h] [rbp-40h] BYREF
  unsigned __int8 v12; // [rsp+AFh] [rbp-21h]
  __int64 v13; // [rsp+B0h] [rbp-20h]
  _QWORD *v14; // [rsp+B8h] [rbp-18h]
  int m; // [rsp+C0h] [rbp-10h]
  int k; // [rsp+C4h] [rbp-Ch]
  int j; // [rsp+C8h] [rbp-8h]
  int i; // [rsp+CCh] [rbp-4h]

  _main();
  feclearexcept(63);
  if ( fetestexcept(3) )
  {
    puts(&#34;Floating point exceptions are set, possibly being debugged.&#34;);
    exit(1);
  }
  if ( IsDebuggerPresent() )
  {
    puts(&#34;This program is being debugged. Exiting!&#34;);
    exit(1);
  }
  printf(&#34;I&#39;m practicing my neuro math skills. Give me nine integers: &#34;);
  scanf(
    &#34;%d %d %d %d %d %d %d %d %d&#34;,
    coeffs,
    &amp;dword_408044,
    &amp;dword_408048,
    &amp;dword_40804C,
    &amp;dword_408050,
    &amp;dword_408054,
    &amp;dword_408058,
    &amp;dword_40805C,
    &amp;dword_408060);
  printf(&#34;Hmm, let me think&#34;);
  v3 = __iob_func();
  fflush(v3 + 1);
  if ( IsDebuggerPresent() )
  {
    puts(&#34;This program is being debugged. Exiting!&#34;);
    exit(1);
  }
  putchar(46);
  v4 = __iob_func();
  fflush(v4 + 1);
  putchar(46);
  v5 = __iob_func();
  fflush(v5 + 1);
  puts(&#34;.&#34;);
  for ( i = -60; i &lt;= 59; ++i )
  {
    total = 0;
    power = 1;
    for ( j = 0; j &lt;= 8; ++j )
    {
      total += power * coeffs[j];
      power *= i;
      result = total;
    }
    if ( i == 44
      || i == 58
      || (::v12 = i + 37, (unsigned int)(i + 37) &lt;= 0x36)
      &amp;&amp; (v14 = &amp;::v5, v13 = (unsigned int)::v12, v6 = ::v5, (v12 = _bittest64(&amp;v6, (unsigned int)::v12)) != 0) )
    {
      if ( IsDebuggerPresent() )
      {
        puts(&#34;This program is being debugged. Exiting!&#34;);
        exit(1);
      }
      if ( result )
        goto LABEL_21;
    }
    else if ( !result )
    {
      if ( IsDebuggerPresent() )
      {
        puts(&#34;This program is being debugged. Exiting!&#34;);
        exit(1);
      }
LABEL_21:
      puts(&#34;Those aren&#39;t the right numbers. Try again!&#34;);
      return 1;
    }
  }
  if ( dword_408060 != 1 )
  {
    for ( k = 0; k &lt;= 8; ++k )
      coeffs[k] /= dword_408060;
  }
  if ( IsDebuggerPresent() )
  {
    puts(&#34;This program is being debugged. Exiting!&#34;);
    exit(1);
  }
  if ( dword_40805C == -80 &amp;&amp; dword_408058 == -358 )
  {
    printf(&#34;Correct! Here&#39;s the flag: &#34;);
    Src[0] = coeffs[0];
    Src[1] = dword_408044;
    Src[2] = dword_408048;
    Src[3] = dword_40804C;
    LOWORD(Src[4]) = dword_408050;
    HIWORD(Src[4]) = dword_408054;
    LOWORD(Src[5]) = dword_408058;
    HIWORD(Src[5]) = dword_40805C;
    LOWORD(Src[6]) = dword_408060;
    memcpy(v9, Src, sizeof(v9));
    memcpy(v10, Src, sizeof(v10));
    for ( m = 0; m &lt;= 51; ++m )
    {
      v9[m] ^= xorcode[m];
      putchar((unsigned __int8)v9[m]);
    }
    putchar(10);
    return 0;
  }
  else
  {
    printf(&#34;WRONG&#34;);
    return 1;
  }
}
</code></pre><p>​ 本质上是一个代码审计加逻辑复写，需要输入九个数。程序前半段大概是这样的公式：</p><p>$$ x_1i^8 + x_2i^7 + x_3i^6 + x_4i^5 + x_5i^4 + x_6i^3 + x_7i^2 + x_8i^1 + x_9i^0 $$</p><p>​ 而后是去计算(i-44)(i-58)(i-17)(i-6)(i-5)(i+4)(i+9)(i+37)————这个巨他妈难看，官方给出的答案是考虑本地模拟 or 动调。</p><p>​ 程序要求用户输入9个整数，存储在 <code>coeffs</code> 数组中。使用这9个整数作为系数，构造一个8次多项式。然后在整数范围 [-60, 59] 内对这个多项式进行求值。对于每个 i 从 -60 到 59：初始化 total = 0 和 power = 1，对每个系数 j 从 0 到 8，然后：</p><ul><li>total += power * coeffs[j]</li><li>power *= i</li></ul><p>​ 最终的 total 就是多项式在 i 点的值。期间验证程序检查多项式在特定点的值是否为0。这些特定点上述以及概括而出。如果上述条件满足，程序会将所有系数除以最后一个系数（如果最后一个系数不等于1）。最终检查： 程序检查调整后的第8个系数是否等于-80，第7个系数是否等于-358。所有条件都满足，程序使用调整后的系数生成一个标志（flag）。生成过程涉及将系数转换为字节，然后与预定义的 xor code 进行异或解密。</p><p>​ 以下是复现：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main(){
    uint64_t v5 = 0x400C0210000001LL;  // 模拟位数组

    for(int x = -60; x &lt;= 60; x++){
        if(x == 44 || x == 58){
            printf(&#34;%d\n&#34;, x);
            continue;
        }

        unsigned int v12 = (unsigned int)(x + 37);

        if(v12 &lt;= 54 &amp;&amp; (v5 &amp; (1ULL &lt;&lt; v12))){
            printf(&#34;%d\n&#34;, x);
        }
    }

    return 0;
}
</code></pre><p>​ 将其展开与上面对比就可以知道x1-x9的数值：</p><pre tabindex=0><code>from sympy import symbols, expand
x = symbols(&#39;x&#39;)
polynomial = (x - 44) * (x - 58) * (x - 5) * (x + 37) * (x - 17) * (x + 9) * (x - 6) * (x + 4)
expanded_polynomial = expand(polynomial)
standard_form = expanded_polynomial.as_poly()
coefficients = standard_form.all_coeffs()
print(coefficients[::-1])
</code></pre><p>​ 输出如下：</p><p><img loading=lazy src=https://img.nanimonai.org/yunxing.png alt></p><p>​ 堂堂完结，代入即可得到flag。</p><p>​ （笔者注：使用cmd打开做，不然那个flag一闪就过去了。）</p><p>​ （事后看了师傅的直播，发现在coeffs这个地方ida里面，它九个整数的地址是连续的，所以可以直接右键改一下，看成一个数组就行）</p></div><footer class=post-footer><ul class=post-tags></ul></footer><script src=https://giscus.app/client.js data-repo=nanimonaic/docx data-repo-id=R_kgDOKiAoMQ data-category-id=DIC_kwDOKiAoMc4CaPcT data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.nanimonai.org/>nanimonai's Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>