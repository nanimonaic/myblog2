<!doctype html><html lang=zh dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="noindex, nofollow"><title>Research on the principle of automatic punch-in | nanimonai's Blog</title>
<meta name=keywords content><meta name=description content="应用"><meta name=author content="nanimonai"><link rel=canonical href=http://localhost:1313/posts/tech/research-on-the-principle-of-automatic-punch-in/><link crossorigin=anonymous href=/assets/css/stylesheet.0aa869c09b4b0cc7fb74b05914fa294a7d4bb5e5bcc7ac5a201534ce91321b93.css integrity="sha256-CqhpwJtLDMf7dLBZFPopSn1LteW8x6xaIBU0zpEyG5M=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://img.nanimonai.org/headimg.jpg><link rel=icon type=image/png sizes=16x16 href=https://img.nanimonai.org/headimg.jpg><link rel=icon type=image/png sizes=32x32 href=https://img.nanimonai.org/headimg.jpg><link rel=apple-touch-icon href=https://img.nanimonai.org/headimg.jpg><link rel=mask-icon href=https://img.nanimonai.org/headimg.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=http://localhost:1313/posts/tech/research-on-the-principle-of-automatic-punch-in/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Neuromancer (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Neuromancer</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=http://localhost:1313/posts title=文章><span>文章</span></a></li><li><a href=http://localhost:1313/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=http://localhost:1313/link title=友链><span>友链</span></a></li><li><a href=http://localhost:1313/about/ title=关于><span>关于</span></a></li><li><a href=http://localhost:1313/archives/ title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>主页</a>&nbsp;»&nbsp;<a href=http://localhost:1313/tech/>技术</a></div><h1 class=post-title>Research on the principle of automatic punch-in</h1><div class=post-description>应用</div></header><div class=post-content><h1 id=这是什么>这是什么<a hidden class=anchor aria-hidden=true href=#这是什么>#</a></h1><p>近日，打卡更新方式，由之前转移到了某一新平台上。求知欲驱使进行研究。写的不周，还请包含，同时我要非常感谢lockey中的一位热心朋友不厌其烦地为我指点迷津。</p><h1 id=如何实现>如何实现<a hidden class=anchor aria-hidden=true href=#如何实现>#</a></h1><h2 id=第一步>第一步<a hidden class=anchor aria-hidden=true href=#第一步>#</a></h2><p>首先是获取签到的数据。</p><p>先去官网下载.apk文件，而众所周知，.apk是一种压缩文件，所以直接解压出来，查找一下发现是rsa，然后思考如何拿到公钥。
<img loading=lazy src=https://img.nanimonai.org/bunan.png alt></p><p>继续find寻找.pem，找到一个证书（本人搞到这里有点绷不住了，真的难绷）</p><p><img loading=lazy src=https://img.nanimonai.org/pem.png alt></p><p>写如下代码以还原出公钥：</p><pre tabindex=0><code>import OpenSSL.crypto

cert_text = &#34;&#34;&#34;
-----BEGIN CERTIFICATE-----
MIIFizCCA3OgAwIBAgIDAJY4MA0GCSqGSIb3DQEBCwUAMIGAMQswCQYDVQQGEwJD
TjEQMA4GA1UECAwHQmVpamluZzEMMAoGA1UECgwDTVNBMREwDwYDVQQLDAhPQUlE
X1NESzEeMBwGA1UEAwwVY29tLmJ1bi5taWl0bWRpZC5zaWduMR4wHAYJKoZIhvcN
AQkBFg9tc2FAY2FpY3QuYWMuY24wHhcNMjQwMTA3MTQ0ODU1WhcNMjUwMTA3MTQ0
ODU1WjB9MQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpamluZzEQMA4GA1UEBwwH
QmVpamluZzEQMA4GA1UECgwHd2phY2tlcjEWMBQGA1UEAwwNY29tLnlpYmFuLmFw
cDEgMB4GCSqGSIb3DQEJARYRd2FuZ2ppZTJAeWliYW4uY24wggIiMA0GCSqGSIb3
DQEBAQUAA4ICDwAwggIKAoICAQCyGC9T3GW4BSsvnVNqb8+HlnjJAQvTPd7H13m1
f945uUsUYYMaaZuICYjb4qefZUyQgyxBUTYfBOTpE7ccdcNoZgCp05RTng30zvkc
4pjawJIkNeIC2NGlN7RquO4Ka/06LSuq5N+bfL78E0MwZAinoxSswf/yNY5R1LJ2
b3I7BnW7rVSb7KbB0Q4z5KmuJ04hPVl7BtSdfVnvnRVTBDRm/cMgyupEl+CCGW8H
UejzPHdHeHRK1rx7fuwQI+5jgMmDYRNXZD4AmJ0vClurQR5avN2xOuxB8HbtB+lQ
itsNnQCvYY1Xp4s7FtfmT6JzDNQ//vRgXxYrOaVFfoY/ugrO+SfZtqej+mdKR3Kg
OaAA75t8zcJfM6WGrbPJl3xHc2bhD4kGwRkTAcHJ7WQOIrWz85CPCfIoYh8nZlBl
sCNamJJh6Pl2nAtmnfMtDuYZJo/2QK6J/KFtywsYIekU6fiRsJaaunBf5sD9Ixbv
JcRRB+HRCsySKYEg8z7Xlh90fHimfUgT0Gt44/o+nzPh7Cq9Ay6dWtMxYFx78Z1e
papOJdUNpZWIET8wQHriJmbJ18TlidGRAW85kW2ka2cr4u6Ed68JQa+nN+kbS0dD
euvOBGOsiqqCy5aeA0oz88HRWWIga02PLTZbEs4PdYrNzHWCISjnk34KpwwxYJUn
6Zpy1wIDAQABoxAwDjAMBgNVHRMBAf8EAjAAMA0GCSqGSIb3DQEBCwUAA4ICAQAk
o30meLI9Un/7KoUekSMhterJ6K11cHKAa+WQqqzp8If+gIhjsyYk7Wf1fgStvoNu
jILWSAfe2C2k74QrlVsUFXue2Ekc+eyDbUhwOi4rVju68/eu4HSpdIUbFQ7ZpivC
adjw7qfN90sp6S+O/dDQ9SzUPBpjMQQ6ZvSTFv7TtZ1cjzOpcfogrDGyOe+mE5Rv
xT3IaWFBcY2fe8lh+/7mJ27A5XgCka1LTZ2OFwI4d1gPWRhwi7R0p4rGhtmk2JJG
viz1rPn8pBBeR5zcwHFuDAbL/1C9d6rZ5lajycrdPZzbcuFAzx7NPafiMsyMYwBK
9oQDIjS5UmfMt+lMFk37yCesFqxq/DOIPm1Hz3N1t5RpcZuwIkCzXYhtOkCbu9SZ
xKqxztpcA5ySf3DWH4TIxKGXxIlC5pr2F4HsmKDIAO/1O6HXI0Bo+s/3KsDS/IMV
nlqKu1WUKUZJebjN/CL61ChfHjkmogslgTkQpJnGsWsix3v0nBFjpbOm/oXYYMJy
p+aMzppKaLx3mniXW/kimteNKu8EdeE7x/QeEIk5IUotfRPAeydVk9yqf+c4ClS9
YwVFAqIDzbC3nLBBXb36WNOoG+MFwWkjKoPhtIoLysTN1gNuFYUlJ1JptoP0Pe0I
k5FWnRRk1vKUktYUfMJE4PQg4sWxZhGkKrGU5zVLsg==
-----END CERTIFICATE-----
&#34;&#34;&#34;

cert=OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert_text)

public_key=OpenSSL.crypto.dump_publickey(OpenSSL.crypto.FILETYPE_PEM, cert.get_pubkey()).decode(&#34;utf-8&#34;)

print(public_key)
</code></pre><p>得出公钥就够用了：</p><p><img loading=lazy src=https://img.nanimonai.org/rsa.png alt></p><h2 id=第二步>第二步<a hidden class=anchor aria-hidden=true href=#第二步>#</a></h2><p>获取cookie，参考github可得：</p><pre tabindex=0><code>
def auth(self):
    COOKIES = {}
    CSRF = &#34;00000000000000000000000000000000&#34;
    HEADERS = {
        &#34;Origin&#34;: &#34;m.yiban.cn&#34;,
        &#34;origin&#34;:&#34;api.uyiban.com&#34;,
        &#34;origin&#34;:&#34;https://c.uyiban.com&#34;,
        &#34;authority&#34;: &#34;api.uyiban.com&#34;,
        &#34;AppVersion&#34;: &#34;5.0.17&#34;,
        &#34;x-requested-with&#34;: &#34;com.yiban.app&#34;,
        &#34;user-agent&#34;:&#34;Mozilla/5.0 (Linux; Android 12; XIAOMI Build/SKQ1.211006.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/112.0.5615.48 Mobile Safari/537.36;webank/h5face;webank/1.0 yiban_android/5.0.17&#34;
        }
    iapp = requests.get(&#34;http://f.yiban.cn/iapp/index?act=iapp7463&#34;, headers=HEADERS, allow_redirects=False, cookies=COOKIES) # 利用 loginToken 访问获取 verifyRequest跳转数据
    # 此处cookie带有 &#34;loginToken&#34; = “cdd6d4432743414c9e1faf3e792*****”
    act = iapp.headers[&#34;Location&#34;] # 返回302跳转目标
    verifyRequest = re.findall(r&#34;verify_request=(.*?)&amp;&#34;, act)[0] # 正则取302跳转目标，得到 verify_request 数据
    json = requests.get(&#34;https://api.uyiban.com/base/c/auth/yiban?verifyRequest=&#34; + verifyRequest + &#34;&amp;CSRF=&#34; + CSRF, headers=HEADERS, allow_redirects=False, cookies={&#39;csrf_token&#39;: CSRF})
    cookies = requests.utils.dict_from_cookiejar(json.cookies) # 获取cookie
    Attendancecookies = cookies # 签到cookies赋值self.Attendancecookies
    print(&#39;Location:&#39;,act,&#34;\n&#34;)
    print(&#39;cookies:&#39;,Attendancecookies,&#34;\n&#34;)
    
    ###打印数据：
    Location: https://c.uyiban.com/#/?verify_request=c9e814****53de92ccc&#39;, &#39;cpi&#39;: &#39;eyJD******%3D%3D&#39;, &#39;is_certified&#39;: &#39;1&#39;}    
    cookies: {&#39;PHPSESSID&#39;: &#39;fa1a28bc38cc**c4b1e87a8ce51f****&#39;, &#39;cpi&#39;: &#39;eyJDaG**%3D%3D&#39;, &#39;is_certified&#39;: &#39;1&#39;}
</code></pre><p>All right. 现在只需要PHPSESSID.</p><h2 id=第三步>第三步<a hidden class=anchor aria-hidden=true href=#第三步>#</a></h2><p>进行ADB调试，其中挺复杂的。我未来也要尝试一下有没有更加简单的调试方法。首先你PC得有Chrome，Firefox就不行。我Linux上面用的是Chromium。第一次尝试的时候移动端使用的是旧版本的Kiwi Browser，导致 chrome://inspect/#devices 这个界面没有inspect fallback选项。更新就行了。</p><p><img loading=lazy src=https://img.nanimonai.org/404.png alt></p><p>在kiwi上找到Network Conditions，把用户代理叉掉并自定义写上MicroMessenger。</p><p><img loading=lazy src=https://img.nanimonai.org/network.png alt></p><p>这个其实可以直接在控制台输入命令获取（忘记截图了，可以自己去试一下）：</p><pre tabindex=0><code>console.log(&#34;User-Agent:&#34;, navigator.userAgent);
</code></pre><p>直接从中间几个开始分析（其实是依葫芦画瓢），能够成功找到https://api.uyiban.com/nightAttendance/student/index/signIn?CSRF=&mldr;</p><p>以及https://api.uyiban.com/nightAttendance/student/index/signPosition?CSRF=&mldr;</p><p>这样就可以进行测试，API 是 RESTful 标准。从登录开始追踪，使用curl去调试。</p><p><img loading=lazy src=https://img.nanimonai.org/gongzuotai.png alt>
<img loading=lazy src=https://img.nanimonai.org/yes.png alt></p><p>错误的都是{&lsquo;code&rsquo;: 500, &lsquo;msg&rsquo;: &lsquo;非法签到&rsquo;, &lsquo;data&rsquo;: None} 0.0</p><p>签到成功会返回{&lsquo;code&rsquo;: 0, &lsquo;msg&rsquo;: &lsquo;&rsquo;, &lsquo;data&rsquo;: True}</p><h2 id=第四步-前人的智慧>第四步 前人的智慧！<a hidden class=anchor aria-hidden=true href=#第四步-前人的智慧>#</a></h2><p>脚本是大爱无私宽仁的Mike修改的，最初版是来自<a href=https://wcyuns.cn/archives/%E6%98%93%E7%8F%AD%E6%99%9A%E7%AD%BE%E8%84%9A%E6%9C%AC>this</a>思路也是借鉴于此，上面也算是重走一遍。真所谓巧夺天工，令人敬佩！</p><pre tabindex=0><code>import json
import re
import sys
import os
import pickle
import time
import urllib
import jsonpath
from urllib import parse
import random
import requests
import numpy
import base64
import msvcrt
try:
    from Crypto.Cipher import PKCS1_v1_5
    from Crypto.PublicKey import RSA
except ModuleNotFoundError:
    print(&#34;缺少pycryptodome依赖！程序将尝试安装依赖！&#34;)
    os.system(&#34;pip3 install pycryptodome -i https://pypi.tuna.tsinghua.edu.cn/simple&#34;)
    os.execl(sys.executable, &#39;python3&#39;, __file__, *sys.argv)

def encryptPassword(pwd): # 登录密码加密
    # 密码加密
    PUBLIC_KEY = &#39;&#39;&#39;-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAzq0rgsM++ZxLRGHpdfre
Hu6UXhdlUS5P2WOxRG14qU8/iWSb/CkOqgOl8AGcOhlthkvolCdpUvVcVsVUxBv0
YRN0Jb64zPrn5aLVwQT4RJn5tXvoqLdHIXis7pljXAMDPVZOVlWJkDMk8YU6HDaA
MqsD6l5p9lg2LMP4OhMgaPX+CkO370LB5vRjJTHp03n+IqfxXoC7DEd+kxRIEM2C
EDgUSYDJBDgwBvGALZmvB/a1b0im9t1P/EmnuE7uN9NRFoWyVpOiEwo/Ti7rmJGf
qNT3vvtfWo4nXsm1rYQXsPayoKDSRaba3gFY/1SYWLAuSO2q2da5ZCcsAk5RKy0V
c1hUg8n6y0YLAvuzoXY5VyNMXkhH5Zc5Kg64b5RxILeZpZG0MV7GFY3sw//k7SNg
darKT8A0Iv3l3lfguX3HNi6dkf97kS/EiA0tbkIB/JNjv13mq8HL7LijRt2hkKqP
PhQW88xC/exZilU5pAavoZOPuZIOTUHqtpRq4ZeKl+wDf+e5lPYFDpihWGjplGpa
4BOSmGeo/SyVFPji9QF4Pk0DRJF/NjwJoAC60xHAVt5Z4gQSOOOjNZDCswA0ry2L
e8m5cv5vPGY75uVrGqALQ6Xm961PPc5cJ1q7tmEZMj+z5HE7tgAdhiPI6acKgrAv
+1k4N0OVqKamMS+PVpD05hUCAwEAAQ==
-----END PUBLIC KEY-----&#39;&#39;&#39;
    cipher = PKCS1_v1_5.new(RSA.importKey(PUBLIC_KEY))
    cipher_text = base64.b64encode(cipher.encrypt(bytes(pwd, encoding=&#34;utf8&#34;)))
    return cipher_text.decode(&#34;utf-8&#34;)
####################################################################################################################################################################################################
####################################################################################################################################################################################################

class yiban:
    COOKIES = {}
    def __init__(self, mobile, password): # 全局变量
        self.mobile = mobile # 登录手机号
        self.password = password # 登录密码
        self.session = requests.session()
        self.HEADERS = {
            &#34;Origin&#34;: &#34;m.yiban.cn&#34;,
            &#34;origin&#34;:&#34;api.uyiban.com&#34;,
            &#34;origin&#34;:&#34;https://c.uyiban.com&#34;,
            &#34;authority&#34;: &#34;api.uyiban.com&#34;,
            &#34;AppVersion&#34;: &#34;5.1.2&#34;,
            &#34;x-requested-with&#34;: &#34;com.yiban.app&#34;,
            &#34;user-agent&#34;:&#34;Mozilla/5.0 (Linux; Android 12; Redmi K30 Pro Build/SKQ1.211006.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/112.0.5615.48 Mobile Safari/537.36;webank/h5face;webank/1.0 yiban_android/5.0.17&#34;
            }
        self.Attendancecookies = {}
        self.CSRF = &#34;00000000000000000000000000000000&#34;

    def login(self): # 登录
        params = {
            &#34;mobile&#34;: self.mobile, #登录手机号
            &#34;password&#34;: encryptPassword(self.password), #RSA加密后的登录密码
            &#34;ct&#34;: &#34;2&#34;, #固定参数
            &#34;identify&#34;: &#34;0&#34;, #固定参数
        }
        # 配置登录数据
        response = requests.post(&#34;https://m.yiban.cn/api/v4/passport/login&#34;, data=params, allow_redirects=False, cookies=self.COOKIES, headers=self.HEADERS).json()
        if response is not None and response[&#34;response&#34;] == 100:
            self.access_token = response[&#34;data&#34;][&#34;access_token&#34;]
            self.HEADERS[&#34;Authorization&#34;] = &#34;Bearer &#34; + self.access_token
            # 增加cookie
            self.COOKIES[&#34;loginToken&#34;] = self.access_token
            print(&#39;用户信息:&#39;,response,&#34;\n&#34;)
            print(&#39;loginToken:&#39;,self.access_token,&#34;\n&#34;)
            print(&#39;用户姓名:&#39;,response[&#34;data&#34;][&#34;user&#34;][&#34;name&#34;],&#34;\n手机号码：&#34;,response[&#34;data&#34;][&#34;user&#34;][&#34;phone&#34;])
            return 1
        else:
            print(response)
            return self.mobile
        #返回https://f.yiban.cn/iapp/index?act=iapp7463所需的Cookie“loginToken=ce196e5fb2900bc35b44e1f1b4ed****”


        #通过获取的loginToken访问iapp后台得到值verifyRequest
        #利用verifyRequest访问api获取签到用的cookie
        #返回cookie内容范例
        #{&#39;PHPSESSID&#39;: &#39;1aef34b976315dca8400711255f1a9af&#39;, &#39;cpi&#39;: &#39;eyJDaGFubmVsIjoieWliYW......TliNWViZTUxYWMifQ%3D%3D&#39;, &#39;is_certified&#39;: &#39;1&#39;}
        #PHPSESSID为关键值，有这一个参数就可以访问签到等相关内容
        #cpi 使用base64编码 有个人相关信息
    def auth(self): # 获取签到cookie
        iapp = requests.get(&#34;http://f.yiban.cn/iapp/index?act=iapp7463&#34;, headers=self.HEADERS, allow_redirects=False, cookies=self.COOKIES) # 利用 loginToken 访问获取 verifyRequest
        act = iapp.headers[&#34;Location&#34;] # 返回302跳转目标
        verifyRequest = re.findall(r&#34;verify_request=(.*?)&amp;&#34;, act)[0] # 正则取302跳转目标，得到 verify_request 数据
        json = requests.get(&#34;https://api.uyiban.com/base/c/auth/yiban?verifyRequest=&#34; + verifyRequest + &#34;&amp;CSRF=&#34; + self.CSRF, headers=self.HEADERS, allow_redirects=False, cookies={&#39;csrf_token&#39;: self.CSRF})
        #访问api获取cookie CSRF值按此可用，只验证位数
        cookies = requests.utils.dict_from_cookiejar(json.cookies) # 获取cookie
        self.Attendancecookies = cookies # 签到cookies赋值self.Attendancecookies
        print(&#39;Location:&#39;,act,&#34;\n&#34;)
        print(&#39;cookies:&#39;,self.Attendancecookies,&#34;\n&#34;)
        return

    def authorization(self, testauth): # 授权校本化
        self.testauth = testauth
        authhtml = requests.get(&#34;https://oauth.yiban.cn/code/html?client_id=95626fa3080300ea&amp;redirect_uri=https://f.yiban.cn/iapp7463&#34;) # 利用 loginToken 访问获取 verifyRequest
        HTML_PUBLIC_KEY = re.search(&#39;&lt;input type=&#34;test&#34; id=&#34;key&#34; value=&#34;((?:.|\n)+)?&#34; style=&#34;display:none&#34;&gt;&#39;,authhtml.text)[1] # 获取网页签到加密 password 证书
        webcookies = requests.utils.dict_from_cookiejar(authhtml.cookies) # 获取校本化授权 cookie    登录需要
        print()
        print(&#34;获取的网页cookie:&#34;,webcookies)
        print(&#34;获取的网页加密证书:&#34;,HTML_PUBLIC_KEY,&#34;\n&#34;)
        HTML_cipher = PKCS1_v1_5.new(RSA.importKey(HTML_PUBLIC_KEY))
        HTML_cipher_text = base64.b64encode(HTML_cipher.encrypt(bytes(self.password, encoding=&#34;utf8&#34;)))
        HTML_cipher_decode = HTML_cipher_text.decode(&#34;utf-8&#34;)
        print(&#34;密码网页加密结果:&#34;,HTML_cipher_decode)
        webparams = {
            &#34;oauth_uname&#34;: self.mobile , # 账号
            &#34;oauth_upwd&#34;: HTML_cipher_decode , # 加密后密码
            &#34;client_id&#34;: &#34;95626fa3080300ea&#34;, # 应用端编号
            &#34;redirect_uri&#34;: &#34;http://f.yiban.cn/iapp7463&#34;, # 应用端回调地址
            }
        webauth = requests.post(&#34;https://oauth.yiban.cn/code/usersure&#34;, data=webparams, cookies=webcookies, headers=self.HEADERS).json()
        print(&#34;授权结果&#34;,webauth,&#34;\n&#34;)
        print(&#34;授权成功，返回获取签到信息中...&#34;)
        return

    def signPosition(self):
        Position = requests.get(&#34;https://api.uyiban.com/nightAttendance/student/index/signPosition?CSRF=&#34; + self.CSRF, allow_redirects=False, cookies={&#39;PHPSESSID&#39;: self.Attendancecookies[&#39;PHPSESSID&#39;], &#39;csrf_token&#39;: self.CSRF}, headers=self.HEADERS).json()
        if Position[&#34;code&#34;] == 0: # 判断是否登录成功
            print(&#34;校本化已授权，有晚签任务\n&#34;)
            print(&#34;可签到数据:&#34;,Position,&#34;\n&#34;)
            State=Position[&#34;data&#34;][&#34;State&#34;] # 获取状态码
            Msg=Position[&#34;data&#34;][&#34;Msg&#34;] # 获取返回信息
            StartTime=Position[&#34;data&#34;][&#34;Range&#34;][&#34;StartTime&#34;] # 获取签到开始时间
            self.StartTime =  StartTime
            EndTime=Position[&#34;data&#34;][&#34;Range&#34;][&#34;EndTime&#34;] # 获取签到结束时间
            pause = StartTime - int(time.time()) # 获取系统现在时间
            if State == 2: # 没有签到任务 如学校没有晚签
                print(&#34;您&#34;,Position[&#34;data&#34;][&#34;Msg&#34;])
                return
            else:
                if State == 3: # 已签到
                    print(&#34;[*] 签到接口返回数据：&#34;,Position[&#34;data&#34;][&#34;Msg&#34;])
                    return
                else:
                    self.Address=jsonpath.jsonpath(Position,&#39;$...Address&#39;)[0] # 获取可签到位置 地址
                    self.LngLat=jsonpath.jsonpath(Position,&#39;$...LngLat&#39;)[0] # 获取可签到位置 经纬度
                    self.lonss = &#39;%.6f&#39; %float(round(float(self.LngLat.split(&#34;,&#34;)[0]),3) + float(random.uniform(0.000100,0.000999))) # 根据地址随机修改经度后3位，达到每次定位位置不一样
                    self.latss = &#39;%.6f&#39; %float(round(float(self.LngLat.split(&#34;,&#34;)[1]),3) + float(random.uniform(0.000100,0.000999))) # 根据地址随机修改纬度后3位，达到每次定位位置不一样
                    if State == 0: # 已经到达签到时间
                        print(&#34;可以签到，立即执行！\n&#34;)
                        self.nightAttendance() # 签到跳转
                    else:
                        if State == 1: # 还未开始签到
                            pause = StartTime - int(time.time()) # 获取剩余时间
                            while pause &gt;= 60 :
                                list = [&#34;\\&#34;, &#34;|&#34;, &#34;/&#34;, &#34;—&#34;]
                                index = pause % 4
                                print(&#34;[*] 距签到时间还有 {} 秒 {}&#34;.format(pause,list[index]), end=&#34;\r&#34;, flush=True)
                                pause = StartTime - int(time.time())
                                time.sleep(1)
                            else:
                                while pause &lt;= 60 and pause &gt;=10 :
                                    print(&#34;[*] 距签到时间还有 {} 秒 {}&#34;.format(pause,list[index]), end=&#34;\r&#34;, flush=True)
                                    pause = StartTime - int(time.time())
                                    time.sleep(0.5)
                                else:
                                    while pause &lt;= 10 :
                                        print(&#34;[*] 距签到时间还有 {} 秒 {}&#34;).format(pause,list[index], end=&#34;\r&#34;, flush=True)
                                        pause = StartTime - int(time.time())
                                        while pause &lt;= 0.25 :
                                            print(&#34;到达签到时间！&#34;)
                                            self.nightAttendance() # 签到跳转
                                            return
                                        time.sleep(0.25)
            if Position[&#34;code&#34;] == 999:
                print(&#34;[*] 晚签信息获取失败\n[*] 有可能是校本化未授权或您的签到页面非本脚本所适配&#34;)
                self.authorization()
        return

    def nightAttendance(self): # 执行签到
        paramss = {
            &#34;Code&#34;: &#34;&#34;,
            &#34;PhoneModel&#34;: &#34;&#34;,
            &#34;SignInfo&#34;: &#39;{&#34;Reason&#34;:&#34;&#34;,&#34;AttachmentFileName&#34;:&#34;&#34;,&#34;LngLat&#34;:&#34;&#39; + self.lonss + &#39;,&#39; + self.latss + &#39;&#34;,&#34;Address&#34;:&#34;&#39; + self.Address + &#39;&#34;}&#39;,
            &#34;OutState&#34;: &#34;1&#34;
            }
        nightsign = requests.post(&#34;https://api.uyiban.com/nightAttendance/student/index/signIn?CSRF=&#34; + self.Attendancecookies[&#39;PHPSESSID&#39;], data=paramss, cookies={&#39;csrf_token&#39;: self.Attendancecookies[&#39;PHPSESSID&#39;], &#39;PHPSESSID&#39;: self.Attendancecookies[&#39;PHPSESSID&#39;]}, headers=self.HEADERS).json()
        print(&#34;签到返回数据:&#34;,nightsign)
        #print(nightsign)
        return self.signPosition() # 跳转回signPosition验证是否签到成功

    def loginin(self): # 登陆校验
        # 应当先判断列表账号是否都能正常登陆
        loginin = self.login() # 登录
        if loginin != 1:
            print(&#34;用户&#34;,loginin,&#34;登陆失败，请处理&#34;)
            print(&#34;按任意键退出脚本&#34;)
            ord(msvcrt.getch())
            sys.exit()
        self.authorization(0) # 校本化授权先执行
        return

    def setall(self): # 多人签到
        loginin = self.login() # 登录
        self.auth() # 授权
        self.signPosition() # 判断能否签到&amp;自动跳转签到
        #self.authorization(0) # 校本化授权 已写入
        return
def save_accounts(accounts):
    with open(&#34;accounts.txt&#34;, &#34;w&#34;) as f:
        for account in accounts:
            f.write(f&#34;{account.mobile},{account.password}\n&#34;)
def load_accounts():
    accounts = []
    if os.path.exists(&#34;accounts.txt&#34;):
        with open(&#34;accounts.txt&#34;, &#34;r&#34;) as f:
            for line in f:
                mobile, password = line.strip().split(&#39;,&#39;)
                accounts.append(yiban(mobile, password))
    return accounts
def display_accounts(accounts):
    print(&#34;当前账户列表:&#34;)
    for idx, account in enumerate(accounts, start=1):
        print(f&#34;{idx}. {account.mobile}&#34;)


def main():
    accounts, disturb_mode, disturb_count = load_accounts()
    if disturb_mode == &#39;on&#39; and disturb_count &gt; 0:
        print(&#34;免打扰模式开启，自动执行...&#34;)
        disturb_count -= 1
    else:
        action = &#39;继续&#39;
        while action.lower() == &#39;继续&#39;:
            display_accounts(accounts)
            choice = input(&#34;要修改或增加账号吗？(修改/增加/执行): &#34;)

            if choice.lower() == &#39;修改&#39;:
                index = int(input(&#34;请输入要修改的账号序号: &#34;)) - 1
                if 0 &lt;= index &lt; len(accounts):
                    new_mobile = input(&#34;输入新的手机号: &#34;)
                    new_password = input(&#34;输入新的密码: &#34;)
                    accounts[index] = yiban(new_mobile, new_password)
                    save_accounts(accounts, disturb_mode, disturb_count)
                    print(&#34;账户已更新&#34;)
            elif choice.lower() == &#39;增加&#39;:
                num_new_accounts = int(input(&#34;请输入要增加的账户数: &#34;))
                for _ in range(num_new_accounts):
                    mobile = input(&#34;请输入新手机号: &#34;)
                    password = input(&#34;请输入新密码: &#34;)
                    accounts.append(yiban(mobile, password))
                save_accounts(accounts, disturb_mode, disturb_count)
                print(&#34;新账户已添加&#34;)
            elif choice.lower() == &#39;执行&#39;:
                break

            action = input(&#34;是否继续修改或增加账户？(继续/执行): &#34;)

        if disturb_count == 0:  # 当不在免打扰模式或免打扰次数用完时询问
            disturb_mode = &#39;on&#39; if input(&#34;是否开启免打扰模式？(是/否): &#34;).lower() == &#39;是&#39; else &#39;off&#39;
            disturb_count = 7 if disturb_mode == &#39;on&#39; else 0

    save_accounts(accounts, disturb_mode, disturb_count)

    for account in accounts:
        account.loginin()
    time.sleep(0.5)
    print(&#34;#签到检查通过#################\n&#34;)
    for account in accounts:
        account.setall()
    time.sleep(0.1)
    print(&#34;##############################&#34;)
    print(&#34;签到任务已执行完成！&#34;)
    sys.exit()


if __name__ == &#34;__main__&#34;:
    main()
</code></pre><h1 id=一点点小改动>一点点小改动<a hidden class=anchor aria-hidden=true href=#一点点小改动>#</a></h1><p>这个脚本有几处在Arch Linux上并不适用。</p><p>pip会往系统里面带脏东西，所以并不能直接执行pip install。会有如下报错：</p><pre tabindex=0><code>pip install numpy
error: externally-managed-environment

× This environment is externally managed
╰─&gt; To install Python packages system-wide, try &#39;pacman -S
    python-xyz&#39;, where xyz is the package you are trying to
    install.
    
    If you wish to install a non-Arch-packaged Python package,
    create a virtual environment using &#39;python -m venv path/to/venv&#39;.
    Then use path/to/venv/bin/python and path/to/venv/bin/pip.
    
    If you wish to install a non-Arch packaged Python application,
    it may be easiest to use &#39;pipx install xyz&#39;, which will manage a
    virtual environment for you. Make sure you have python-pipx
    installed via pacman.

note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.
hint: See PEP 668 for the detailed specification.
</code></pre><p>最恰当的方法应该是给他来个虚拟环境。且msvcrt是一个Windows特定的模块，在Linux上不可用，可以代码里面直接给它扬了：</p><pre tabindex=0><code>...# 上述代码照抄

def loginin(self): # 登陆校验
    # 应当先判断列表账号是否都能正常登陆
    loginin = self.login() # 登录
    if loginin != 1:
        print(&#34;用户&#34;,loginin,&#34;登陆失败，请处理&#34;)
        print(&#34;按任意键退出脚本&#34;)# 移除了msvcrt.getch()，因为在Linux上不可用
        input(&#34;按回车键退出脚本&#34;)
        sys.exit()
    self.authorization(0) # 校本化授权先执行
    return
    
...# 下面照抄
</code></pre><p>构建虚拟环境需要：</p><pre tabindex=0><code>python3 -m venv /path/to/new/virtual/environment

source /path/to/new/virtual/environment/bin/activate

pip install requests numpy jsonpath

deactivate
</code></pre><p>在你的py文件目录下创建一个.sh：</p><pre tabindex=0><code>#!/bin/bash

VENV_DIR=&#34;/path/to/your/venv&#34;

SCRIPT_PATH=&#34;/path/to/your/script.py&#34;

source &#34;$VENV_DIR/bin/activate&#34;

python &#34;$SCRIPT_PATH&#34;

deactivate

chmod +x /path/to/your/script.sh
/path/to/your/script.sh
</code></pre><p>然后就是考虑在Linux上如何进行定时任务的问题，经某位lockey朋友启发选择直接上大家所熟悉的cron：</p><pre tabindex=0><code>sudo pacman -S cronie
sudo systemctl start cronie.service
sudo systemctl enable cronie.service

crontab -e # 转入nano编辑
0 0 * * * /path/to/your/script.sh # 自行照格式修改

#ctrl+o写入，enter，ctrl+x退出

crontab -l # 检查一下有没有写好
</code></pre><p><strong>DONE.</strong></p></div><footer class=post-footer><ul class=post-tags></ul></footer><script src=https://giscus.app/client.js data-repo=nanimonaic/docx data-repo-id=R_kgDOKiAoMQ data-category-id=DIC_kwDOKiAoMc4CaPcT data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>nanimonai's Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>