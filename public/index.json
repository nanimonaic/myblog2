[{"content":"应某人之邀，写文以记述经历，即使失败，也可以给后人留下一点宝贵经验。\n事实证明他是正确的。\n关于自制PCB的环节进行简述：\n1. 嘉立创画图 2. 生成文件 3. 导出掩膜(电路的镜像)，打印在掩膜纸上 4. 压印，采用热转印机 5. 蚀刻，环保腐蚀液蚀刻 6. 镀锡 (锡膏刷在铜板上，上加热台) (可选步骤) 这是截止到2024年8月28日的生产线，未来会进行改进。这样只能蚀刻出单层板，如果有一些被隔开如VCC、VEE时需要填充区域飞线。热转印的时候需要注意，过程高温需要有人看守，切割铜板切勿戴手套。蚀刻步骤时需要戴一次性手套，不能直接接触腐蚀液。使用专用的烧杯盛放腐蚀液，烧杯加热台加热烧杯使其蚀刻更快。但不宜过久，导致可能的掩膜脱落线路被蚀刻。如需打孔需要注意小钻头的转速不能过高，会崩飞钻头，高速旋转的钻头飞出来是很可怕的。操作加热台镀锡的时候需要在锡融化的时候刮平，后面好上贴片或者飞线。\n自制板子也有可能出现一些离奇的原因未知的问题，例如原理图相同的lcr电桥模块自制时波形非常始终不能令人满意，在进行修改的时候，我他妈把sma吹下来的时候直接把那个中间内孔的覆铜带下来了。传奇红温。后面尝试嘉立创打了一块就没问题，参考设计和抄板子也很重要。\n剩下非常多的是经验的区别，亲身经历后无法解决，借鉴又借鉴不到类似情况的东西，就会红温。时机恰当的时候，共地不完整也会干碎心态。\n(未完待续\u0026hellip;)\n","permalink":"https://blog.nanimonai.org/posts/tech/electronics-design-contest-before/","summary":"\u003cp\u003e应某人之邀，写文以记述经历，即使失败，也可以给后人留下一点宝贵经验。\u003c/p\u003e\n\u003cp\u003e事实证明他是正确的。\u003c/p\u003e\n\u003cp\u003e关于自制PCB的环节进行简述：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"l\"\u003e. 嘉立创画图\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"m\"\u003e2\u003c/span\u003e\u003cspan class=\"l\"\u003e. 生成文件\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"m\"\u003e3\u003c/span\u003e\u003cspan class=\"l\"\u003e. 导出掩膜(电路的镜像)，打印在掩膜纸上\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"m\"\u003e4\u003c/span\u003e\u003cspan class=\"l\"\u003e. 压印，采用热转印机\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"m\"\u003e5\u003c/span\u003e\u003cspan class=\"l\"\u003e. 蚀刻，环保腐蚀液蚀刻\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"m\"\u003e6\u003c/span\u003e\u003cspan class=\"l\"\u003e. 镀锡 (锡膏刷在铜板上，上加热台) (可选步骤)\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这是截止到2024年8月28日的生产线，未来会进行改进。这样只能蚀刻出单层板，如果有一些被隔开如VCC、VEE时需要填充区域飞线。热转印的时候需要注意，过程高温需要有人看守，切割铜板切勿戴手套。蚀刻步骤时需要戴一次性手套，不能直接接触腐蚀液。使用专用的烧杯盛放腐蚀液，烧杯加热台加热烧杯使其蚀刻更快。但不宜过久，导致可能的掩膜脱落线路被蚀刻。如需打孔需要注意小钻头的转速不能过高，会崩飞钻头，高速旋转的钻头飞出来是很可怕的。操作加热台镀锡的时候需要在锡融化的时候刮平，后面好上贴片或者飞线。\u003c/p\u003e\n\u003cp\u003e自制板子也有可能出现一些离奇的原因未知的问题，例如原理图相同的lcr电桥模块自制时波形非常始终不能令人满意，在进行修改的时候，我他妈把sma吹下来的时候直接把那个中间内孔的覆铜带下来了。传奇红温。后面尝试嘉立创打了一块就没问题，参考设计和抄板子也很重要。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://s3.tebi.io/img.nanimonai.org/lcr.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e剩下非常多的是经验的区别，亲身经历后无法解决，借鉴又借鉴不到类似情况的东西，就会红温。时机恰当的时候，共地不完整也会干碎心态。\u003c/p\u003e\n\u003cp\u003e(未完待续\u0026hellip;)\u003c/p\u003e","title":"Electronics Design Contest 1"},{"content":"这是什么 近日，打卡更新方式，由之前转移到了某一新平台上。求知欲驱使进行研究。写的不周，还请包含，同时我要非常感谢lockey中的一位热心朋友不厌其烦地为我指点迷津。\n如何实现 第一步 首先是获取签到的数据。\n先去官网下载.apk文件，而众所周知，.apk是一种压缩文件，所以直接解压出来，查找一下发现是rsa，然后思考如何拿到公钥。 继续find寻找.pem，找到一个证书（本人搞到这里有点绷不住了，真的难绷）\n写如下代码以还原出公钥：\nimport OpenSSL.crypto cert_text = \u0026#34;\u0026#34;\u0026#34; -----BEGIN CERTIFICATE----- MIIFizCCA3OgAwIBAgIDAJY4MA0GCSqGSIb3DQEBCwUAMIGAMQswCQYDVQQGEwJD TjEQMA4GA1UECAwHQmVpamluZzEMMAoGA1UECgwDTVNBMREwDwYDVQQLDAhPQUlE X1NESzEeMBwGA1UEAwwVY29tLmJ1bi5taWl0bWRpZC5zaWduMR4wHAYJKoZIhvcN AQkBFg9tc2FAY2FpY3QuYWMuY24wHhcNMjQwMTA3MTQ0ODU1WhcNMjUwMTA3MTQ0 ODU1WjB9MQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpamluZzEQMA4GA1UEBwwH QmVpamluZzEQMA4GA1UECgwHd2phY2tlcjEWMBQGA1UEAwwNY29tLnlpYmFuLmFw cDEgMB4GCSqGSIb3DQEJARYRd2FuZ2ppZTJAeWliYW4uY24wggIiMA0GCSqGSIb3 DQEBAQUAA4ICDwAwggIKAoICAQCyGC9T3GW4BSsvnVNqb8+HlnjJAQvTPd7H13m1 f945uUsUYYMaaZuICYjb4qefZUyQgyxBUTYfBOTpE7ccdcNoZgCp05RTng30zvkc 4pjawJIkNeIC2NGlN7RquO4Ka/06LSuq5N+bfL78E0MwZAinoxSswf/yNY5R1LJ2 b3I7BnW7rVSb7KbB0Q4z5KmuJ04hPVl7BtSdfVnvnRVTBDRm/cMgyupEl+CCGW8H UejzPHdHeHRK1rx7fuwQI+5jgMmDYRNXZD4AmJ0vClurQR5avN2xOuxB8HbtB+lQ itsNnQCvYY1Xp4s7FtfmT6JzDNQ//vRgXxYrOaVFfoY/ugrO+SfZtqej+mdKR3Kg OaAA75t8zcJfM6WGrbPJl3xHc2bhD4kGwRkTAcHJ7WQOIrWz85CPCfIoYh8nZlBl sCNamJJh6Pl2nAtmnfMtDuYZJo/2QK6J/KFtywsYIekU6fiRsJaaunBf5sD9Ixbv JcRRB+HRCsySKYEg8z7Xlh90fHimfUgT0Gt44/o+nzPh7Cq9Ay6dWtMxYFx78Z1e papOJdUNpZWIET8wQHriJmbJ18TlidGRAW85kW2ka2cr4u6Ed68JQa+nN+kbS0dD euvOBGOsiqqCy5aeA0oz88HRWWIga02PLTZbEs4PdYrNzHWCISjnk34KpwwxYJUn 6Zpy1wIDAQABoxAwDjAMBgNVHRMBAf8EAjAAMA0GCSqGSIb3DQEBCwUAA4ICAQAk o30meLI9Un/7KoUekSMhterJ6K11cHKAa+WQqqzp8If+gIhjsyYk7Wf1fgStvoNu jILWSAfe2C2k74QrlVsUFXue2Ekc+eyDbUhwOi4rVju68/eu4HSpdIUbFQ7ZpivC adjw7qfN90sp6S+O/dDQ9SzUPBpjMQQ6ZvSTFv7TtZ1cjzOpcfogrDGyOe+mE5Rv xT3IaWFBcY2fe8lh+/7mJ27A5XgCka1LTZ2OFwI4d1gPWRhwi7R0p4rGhtmk2JJG viz1rPn8pBBeR5zcwHFuDAbL/1C9d6rZ5lajycrdPZzbcuFAzx7NPafiMsyMYwBK 9oQDIjS5UmfMt+lMFk37yCesFqxq/DOIPm1Hz3N1t5RpcZuwIkCzXYhtOkCbu9SZ xKqxztpcA5ySf3DWH4TIxKGXxIlC5pr2F4HsmKDIAO/1O6HXI0Bo+s/3KsDS/IMV nlqKu1WUKUZJebjN/CL61ChfHjkmogslgTkQpJnGsWsix3v0nBFjpbOm/oXYYMJy p+aMzppKaLx3mniXW/kimteNKu8EdeE7x/QeEIk5IUotfRPAeydVk9yqf+c4ClS9 YwVFAqIDzbC3nLBBXb36WNOoG+MFwWkjKoPhtIoLysTN1gNuFYUlJ1JptoP0Pe0I k5FWnRRk1vKUktYUfMJE4PQg4sWxZhGkKrGU5zVLsg== -----END CERTIFICATE----- \u0026#34;\u0026#34;\u0026#34; cert=OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert_text) public_key=OpenSSL.crypto.dump_publickey(OpenSSL.crypto.FILETYPE_PEM, cert.get_pubkey()).decode(\u0026#34;utf-8\u0026#34;) print(public_key) 得出公钥就够用了：\n第二步 获取cookie，参考github可得：\ndef auth(self): COOKIES = {} CSRF = \u0026#34;00000000000000000000000000000000\u0026#34; HEADERS = { \u0026#34;Origin\u0026#34;: \u0026#34;m.yiban.cn\u0026#34;, \u0026#34;origin\u0026#34;:\u0026#34;api.uyiban.com\u0026#34;, \u0026#34;origin\u0026#34;:\u0026#34;https://c.uyiban.com\u0026#34;, \u0026#34;authority\u0026#34;: \u0026#34;api.uyiban.com\u0026#34;, \u0026#34;AppVersion\u0026#34;: \u0026#34;5.0.17\u0026#34;, \u0026#34;x-requested-with\u0026#34;: \u0026#34;com.yiban.app\u0026#34;, \u0026#34;user-agent\u0026#34;:\u0026#34;Mozilla/5.0 (Linux; Android 12; XIAOMI Build/SKQ1.211006.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/112.0.5615.48 Mobile Safari/537.36;webank/h5face;webank/1.0 yiban_android/5.0.17\u0026#34; } iapp = requests.get(\u0026#34;http://f.yiban.cn/iapp/index?act=iapp7463\u0026#34;, headers=HEADERS, allow_redirects=False, cookies=COOKIES) # 利用 loginToken 访问获取 verifyRequest跳转数据 # 此处cookie带有 \u0026#34;loginToken\u0026#34; = “cdd6d4432743414c9e1faf3e792*****” act = iapp.headers[\u0026#34;Location\u0026#34;] # 返回302跳转目标 verifyRequest = re.findall(r\u0026#34;verify_request=(.*?)\u0026amp;\u0026#34;, act)[0] # 正则取302跳转目标，得到 verify_request 数据 json = requests.get(\u0026#34;https://api.uyiban.com/base/c/auth/yiban?verifyRequest=\u0026#34; + verifyRequest + \u0026#34;\u0026amp;CSRF=\u0026#34; + CSRF, headers=HEADERS, allow_redirects=False, cookies={\u0026#39;csrf_token\u0026#39;: CSRF}) cookies = requests.utils.dict_from_cookiejar(json.cookies) # 获取cookie Attendancecookies = cookies # 签到cookies赋值self.Attendancecookies print(\u0026#39;Location:\u0026#39;,act,\u0026#34;\\n\u0026#34;) print(\u0026#39;cookies:\u0026#39;,Attendancecookies,\u0026#34;\\n\u0026#34;) ###打印数据： Location: https://c.uyiban.com/#/?verify_request=c9e814****53de92ccc\u0026#39;, \u0026#39;cpi\u0026#39;: \u0026#39;eyJD******%3D%3D\u0026#39;, \u0026#39;is_certified\u0026#39;: \u0026#39;1\u0026#39;} cookies: {\u0026#39;PHPSESSID\u0026#39;: \u0026#39;fa1a28bc38cc**c4b1e87a8ce51f****\u0026#39;, \u0026#39;cpi\u0026#39;: \u0026#39;eyJDaG**%3D%3D\u0026#39;, \u0026#39;is_certified\u0026#39;: \u0026#39;1\u0026#39;} All right. 现在只需要PHPSESSID.\n第三步 进行ADB调试，其中挺复杂的。我未来也要尝试一下有没有更加简单的调试方法。首先你PC得有Chrome，Firefox就不行。我Linux上面用的是Chromium。第一次尝试的时候移动端使用的是旧版本的Kiwi Browser，导致 chrome://inspect/#devices 这个界面没有inspect fallback选项。更新就行了。\n在kiwi上找到Network Conditions，把用户代理叉掉并自定义写上MicroMessenger。\n这个其实可以直接在控制台输入命令获取（忘记截图了，可以自己去试一下）：\nconsole.log(\u0026#34;User-Agent:\u0026#34;, navigator.userAgent); 直接从中间几个开始分析（其实是依葫芦画瓢），能够成功找到https://api.uyiban.com/nightAttendance/student/index/signIn?CSRF=\u0026hellip;\n以及https://api.uyiban.com/nightAttendance/student/index/signPosition?CSRF=\u0026hellip;\n这样就可以进行测试，API 是 RESTful 标准。从登录开始追踪，使用curl去调试。\n错误的都是{\u0026lsquo;code\u0026rsquo;: 500, \u0026lsquo;msg\u0026rsquo;: \u0026lsquo;非法签到\u0026rsquo;, \u0026lsquo;data\u0026rsquo;: None}\t0.0\n签到成功会返回{\u0026lsquo;code\u0026rsquo;: 0, \u0026lsquo;msg\u0026rsquo;: \u0026lsquo;\u0026rsquo;, \u0026lsquo;data\u0026rsquo;: True}\n第四步 前人的智慧！ 脚本是大爱无私宽仁的Mike修改的，最初版是来自this思路也是借鉴于此，上面也算是重走一遍。真所谓巧夺天工，令人敬佩！\nimport json import re import sys import os import pickle import time import urllib import jsonpath from urllib import parse import random import requests import numpy import base64 import msvcrt try: from Crypto.Cipher import PKCS1_v1_5 from Crypto.PublicKey import RSA except ModuleNotFoundError: print(\u0026#34;缺少pycryptodome依赖！程序将尝试安装依赖！\u0026#34;) os.system(\u0026#34;pip3 install pycryptodome -i https://pypi.tuna.tsinghua.edu.cn/simple\u0026#34;) os.execl(sys.executable, \u0026#39;python3\u0026#39;, __file__, *sys.argv) def encryptPassword(pwd): # 登录密码加密 # 密码加密 PUBLIC_KEY = \u0026#39;\u0026#39;\u0026#39;-----BEGIN PUBLIC KEY----- MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAzq0rgsM++ZxLRGHpdfre Hu6UXhdlUS5P2WOxRG14qU8/iWSb/CkOqgOl8AGcOhlthkvolCdpUvVcVsVUxBv0 YRN0Jb64zPrn5aLVwQT4RJn5tXvoqLdHIXis7pljXAMDPVZOVlWJkDMk8YU6HDaA MqsD6l5p9lg2LMP4OhMgaPX+CkO370LB5vRjJTHp03n+IqfxXoC7DEd+kxRIEM2C EDgUSYDJBDgwBvGALZmvB/a1b0im9t1P/EmnuE7uN9NRFoWyVpOiEwo/Ti7rmJGf qNT3vvtfWo4nXsm1rYQXsPayoKDSRaba3gFY/1SYWLAuSO2q2da5ZCcsAk5RKy0V c1hUg8n6y0YLAvuzoXY5VyNMXkhH5Zc5Kg64b5RxILeZpZG0MV7GFY3sw//k7SNg darKT8A0Iv3l3lfguX3HNi6dkf97kS/EiA0tbkIB/JNjv13mq8HL7LijRt2hkKqP PhQW88xC/exZilU5pAavoZOPuZIOTUHqtpRq4ZeKl+wDf+e5lPYFDpihWGjplGpa 4BOSmGeo/SyVFPji9QF4Pk0DRJF/NjwJoAC60xHAVt5Z4gQSOOOjNZDCswA0ry2L e8m5cv5vPGY75uVrGqALQ6Xm961PPc5cJ1q7tmEZMj+z5HE7tgAdhiPI6acKgrAv +1k4N0OVqKamMS+PVpD05hUCAwEAAQ== -----END PUBLIC KEY-----\u0026#39;\u0026#39;\u0026#39; cipher = PKCS1_v1_5.new(RSA.importKey(PUBLIC_KEY)) cipher_text = base64.b64encode(cipher.encrypt(bytes(pwd, encoding=\u0026#34;utf8\u0026#34;))) return cipher_text.decode(\u0026#34;utf-8\u0026#34;) #################################################################################################################################################################################################### #################################################################################################################################################################################################### class yiban: COOKIES = {} def __init__(self, mobile, password): # 全局变量 self.mobile = mobile # 登录手机号 self.password = password # 登录密码 self.session = requests.session() self.HEADERS = { \u0026#34;Origin\u0026#34;: \u0026#34;m.yiban.cn\u0026#34;, \u0026#34;origin\u0026#34;:\u0026#34;api.uyiban.com\u0026#34;, \u0026#34;origin\u0026#34;:\u0026#34;https://c.uyiban.com\u0026#34;, \u0026#34;authority\u0026#34;: \u0026#34;api.uyiban.com\u0026#34;, \u0026#34;AppVersion\u0026#34;: \u0026#34;5.1.2\u0026#34;, \u0026#34;x-requested-with\u0026#34;: \u0026#34;com.yiban.app\u0026#34;, \u0026#34;user-agent\u0026#34;:\u0026#34;Mozilla/5.0 (Linux; Android 12; Redmi K30 Pro Build/SKQ1.211006.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/112.0.5615.48 Mobile Safari/537.36;webank/h5face;webank/1.0 yiban_android/5.0.17\u0026#34; } self.Attendancecookies = {} self.CSRF = \u0026#34;00000000000000000000000000000000\u0026#34; def login(self): # 登录 params = { \u0026#34;mobile\u0026#34;: self.mobile, #登录手机号 \u0026#34;password\u0026#34;: encryptPassword(self.password), #RSA加密后的登录密码 \u0026#34;ct\u0026#34;: \u0026#34;2\u0026#34;, #固定参数 \u0026#34;identify\u0026#34;: \u0026#34;0\u0026#34;, #固定参数 } # 配置登录数据 response = requests.post(\u0026#34;https://m.yiban.cn/api/v4/passport/login\u0026#34;, data=params, allow_redirects=False, cookies=self.COOKIES, headers=self.HEADERS).json() if response is not None and response[\u0026#34;response\u0026#34;] == 100: self.access_token = response[\u0026#34;data\u0026#34;][\u0026#34;access_token\u0026#34;] self.HEADERS[\u0026#34;Authorization\u0026#34;] = \u0026#34;Bearer \u0026#34; + self.access_token # 增加cookie self.COOKIES[\u0026#34;loginToken\u0026#34;] = self.access_token print(\u0026#39;用户信息:\u0026#39;,response,\u0026#34;\\n\u0026#34;) print(\u0026#39;loginToken:\u0026#39;,self.access_token,\u0026#34;\\n\u0026#34;) print(\u0026#39;用户姓名:\u0026#39;,response[\u0026#34;data\u0026#34;][\u0026#34;user\u0026#34;][\u0026#34;name\u0026#34;],\u0026#34;\\n手机号码：\u0026#34;,response[\u0026#34;data\u0026#34;][\u0026#34;user\u0026#34;][\u0026#34;phone\u0026#34;]) return 1 else: print(response) return self.mobile #返回https://f.yiban.cn/iapp/index?act=iapp7463所需的Cookie“loginToken=ce196e5fb2900bc35b44e1f1b4ed****” #通过获取的loginToken访问iapp后台得到值verifyRequest #利用verifyRequest访问api获取签到用的cookie #返回cookie内容范例 #{\u0026#39;PHPSESSID\u0026#39;: \u0026#39;1aef34b976315dca8400711255f1a9af\u0026#39;, \u0026#39;cpi\u0026#39;: \u0026#39;eyJDaGFubmVsIjoieWliYW......TliNWViZTUxYWMifQ%3D%3D\u0026#39;, \u0026#39;is_certified\u0026#39;: \u0026#39;1\u0026#39;} #PHPSESSID为关键值，有这一个参数就可以访问签到等相关内容 #cpi 使用base64编码 有个人相关信息 def auth(self): # 获取签到cookie iapp = requests.get(\u0026#34;http://f.yiban.cn/iapp/index?act=iapp7463\u0026#34;, headers=self.HEADERS, allow_redirects=False, cookies=self.COOKIES) # 利用 loginToken 访问获取 verifyRequest act = iapp.headers[\u0026#34;Location\u0026#34;] # 返回302跳转目标 verifyRequest = re.findall(r\u0026#34;verify_request=(.*?)\u0026amp;\u0026#34;, act)[0] # 正则取302跳转目标，得到 verify_request 数据 json = requests.get(\u0026#34;https://api.uyiban.com/base/c/auth/yiban?verifyRequest=\u0026#34; + verifyRequest + \u0026#34;\u0026amp;CSRF=\u0026#34; + self.CSRF, headers=self.HEADERS, allow_redirects=False, cookies={\u0026#39;csrf_token\u0026#39;: self.CSRF}) #访问api获取cookie CSRF值按此可用，只验证位数 cookies = requests.utils.dict_from_cookiejar(json.cookies) # 获取cookie self.Attendancecookies = cookies # 签到cookies赋值self.Attendancecookies print(\u0026#39;Location:\u0026#39;,act,\u0026#34;\\n\u0026#34;) print(\u0026#39;cookies:\u0026#39;,self.Attendancecookies,\u0026#34;\\n\u0026#34;) return def authorization(self, testauth): # 授权校本化 self.testauth = testauth authhtml = requests.get(\u0026#34;https://oauth.yiban.cn/code/html?client_id=95626fa3080300ea\u0026amp;redirect_uri=https://f.yiban.cn/iapp7463\u0026#34;) # 利用 loginToken 访问获取 verifyRequest HTML_PUBLIC_KEY = re.search(\u0026#39;\u0026lt;input type=\u0026#34;test\u0026#34; id=\u0026#34;key\u0026#34; value=\u0026#34;((?:.|\\n)+)?\u0026#34; style=\u0026#34;display:none\u0026#34;\u0026gt;\u0026#39;,authhtml.text)[1] # 获取网页签到加密 password 证书 webcookies = requests.utils.dict_from_cookiejar(authhtml.cookies) # 获取校本化授权 cookie 登录需要 print() print(\u0026#34;获取的网页cookie:\u0026#34;,webcookies) print(\u0026#34;获取的网页加密证书:\u0026#34;,HTML_PUBLIC_KEY,\u0026#34;\\n\u0026#34;) HTML_cipher = PKCS1_v1_5.new(RSA.importKey(HTML_PUBLIC_KEY)) HTML_cipher_text = base64.b64encode(HTML_cipher.encrypt(bytes(self.password, encoding=\u0026#34;utf8\u0026#34;))) HTML_cipher_decode = HTML_cipher_text.decode(\u0026#34;utf-8\u0026#34;) print(\u0026#34;密码网页加密结果:\u0026#34;,HTML_cipher_decode) webparams = { \u0026#34;oauth_uname\u0026#34;: self.mobile , # 账号 \u0026#34;oauth_upwd\u0026#34;: HTML_cipher_decode , # 加密后密码 \u0026#34;client_id\u0026#34;: \u0026#34;95626fa3080300ea\u0026#34;, # 应用端编号 \u0026#34;redirect_uri\u0026#34;: \u0026#34;http://f.yiban.cn/iapp7463\u0026#34;, # 应用端回调地址 } webauth = requests.post(\u0026#34;https://oauth.yiban.cn/code/usersure\u0026#34;, data=webparams, cookies=webcookies, headers=self.HEADERS).json() print(\u0026#34;授权结果\u0026#34;,webauth,\u0026#34;\\n\u0026#34;) print(\u0026#34;授权成功，返回获取签到信息中...\u0026#34;) return def signPosition(self): Position = requests.get(\u0026#34;https://api.uyiban.com/nightAttendance/student/index/signPosition?CSRF=\u0026#34; + self.CSRF, allow_redirects=False, cookies={\u0026#39;PHPSESSID\u0026#39;: self.Attendancecookies[\u0026#39;PHPSESSID\u0026#39;], \u0026#39;csrf_token\u0026#39;: self.CSRF}, headers=self.HEADERS).json() if Position[\u0026#34;code\u0026#34;] == 0: # 判断是否登录成功 print(\u0026#34;校本化已授权，有晚签任务\\n\u0026#34;) print(\u0026#34;可签到数据:\u0026#34;,Position,\u0026#34;\\n\u0026#34;) State=Position[\u0026#34;data\u0026#34;][\u0026#34;State\u0026#34;] # 获取状态码 Msg=Position[\u0026#34;data\u0026#34;][\u0026#34;Msg\u0026#34;] # 获取返回信息 StartTime=Position[\u0026#34;data\u0026#34;][\u0026#34;Range\u0026#34;][\u0026#34;StartTime\u0026#34;] # 获取签到开始时间 self.StartTime = StartTime EndTime=Position[\u0026#34;data\u0026#34;][\u0026#34;Range\u0026#34;][\u0026#34;EndTime\u0026#34;] # 获取签到结束时间 pause = StartTime - int(time.time()) # 获取系统现在时间 if State == 2: # 没有签到任务 如学校没有晚签 print(\u0026#34;您\u0026#34;,Position[\u0026#34;data\u0026#34;][\u0026#34;Msg\u0026#34;]) return else: if State == 3: # 已签到 print(\u0026#34;[*] 签到接口返回数据：\u0026#34;,Position[\u0026#34;data\u0026#34;][\u0026#34;Msg\u0026#34;]) return else: self.Address=jsonpath.jsonpath(Position,\u0026#39;$...Address\u0026#39;)[0] # 获取可签到位置 地址 self.LngLat=jsonpath.jsonpath(Position,\u0026#39;$...LngLat\u0026#39;)[0] # 获取可签到位置 经纬度 self.lonss = \u0026#39;%.6f\u0026#39; %float(round(float(self.LngLat.split(\u0026#34;,\u0026#34;)[0]),3) + float(random.uniform(0.000100,0.000999))) # 根据地址随机修改经度后3位，达到每次定位位置不一样 self.latss = \u0026#39;%.6f\u0026#39; %float(round(float(self.LngLat.split(\u0026#34;,\u0026#34;)[1]),3) + float(random.uniform(0.000100,0.000999))) # 根据地址随机修改纬度后3位，达到每次定位位置不一样 if State == 0: # 已经到达签到时间 print(\u0026#34;可以签到，立即执行！\\n\u0026#34;) self.nightAttendance() # 签到跳转 else: if State == 1: # 还未开始签到 pause = StartTime - int(time.time()) # 获取剩余时间 while pause \u0026gt;= 60 : list = [\u0026#34;\\\\\u0026#34;, \u0026#34;|\u0026#34;, \u0026#34;/\u0026#34;, \u0026#34;—\u0026#34;] index = pause % 4 print(\u0026#34;[*] 距签到时间还有 {} 秒 {}\u0026#34;.format(pause,list[index]), end=\u0026#34;\\r\u0026#34;, flush=True) pause = StartTime - int(time.time()) time.sleep(1) else: while pause \u0026lt;= 60 and pause \u0026gt;=10 : print(\u0026#34;[*] 距签到时间还有 {} 秒 {}\u0026#34;.format(pause,list[index]), end=\u0026#34;\\r\u0026#34;, flush=True) pause = StartTime - int(time.time()) time.sleep(0.5) else: while pause \u0026lt;= 10 : print(\u0026#34;[*] 距签到时间还有 {} 秒 {}\u0026#34;).format(pause,list[index], end=\u0026#34;\\r\u0026#34;, flush=True) pause = StartTime - int(time.time()) while pause \u0026lt;= 0.25 : print(\u0026#34;到达签到时间！\u0026#34;) self.nightAttendance() # 签到跳转 return time.sleep(0.25) if Position[\u0026#34;code\u0026#34;] == 999: print(\u0026#34;[*] 晚签信息获取失败\\n[*] 有可能是校本化未授权或您的签到页面非本脚本所适配\u0026#34;) self.authorization() return def nightAttendance(self): # 执行签到 paramss = { \u0026#34;Code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;PhoneModel\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;SignInfo\u0026#34;: \u0026#39;{\u0026#34;Reason\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;AttachmentFileName\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;LngLat\u0026#34;:\u0026#34;\u0026#39; + self.lonss + \u0026#39;,\u0026#39; + self.latss + \u0026#39;\u0026#34;,\u0026#34;Address\u0026#34;:\u0026#34;\u0026#39; + self.Address + \u0026#39;\u0026#34;}\u0026#39;, \u0026#34;OutState\u0026#34;: \u0026#34;1\u0026#34; } nightsign = requests.post(\u0026#34;https://api.uyiban.com/nightAttendance/student/index/signIn?CSRF=\u0026#34; + self.Attendancecookies[\u0026#39;PHPSESSID\u0026#39;], data=paramss, cookies={\u0026#39;csrf_token\u0026#39;: self.Attendancecookies[\u0026#39;PHPSESSID\u0026#39;], \u0026#39;PHPSESSID\u0026#39;: self.Attendancecookies[\u0026#39;PHPSESSID\u0026#39;]}, headers=self.HEADERS).json() print(\u0026#34;签到返回数据:\u0026#34;,nightsign) #print(nightsign) return self.signPosition() # 跳转回signPosition验证是否签到成功 def loginin(self): # 登陆校验 # 应当先判断列表账号是否都能正常登陆 loginin = self.login() # 登录 if loginin != 1: print(\u0026#34;用户\u0026#34;,loginin,\u0026#34;登陆失败，请处理\u0026#34;) print(\u0026#34;按任意键退出脚本\u0026#34;) ord(msvcrt.getch()) sys.exit() self.authorization(0) # 校本化授权先执行 return def setall(self): # 多人签到 loginin = self.login() # 登录 self.auth() # 授权 self.signPosition() # 判断能否签到\u0026amp;自动跳转签到 #self.authorization(0) # 校本化授权 已写入 return def save_accounts(accounts): with open(\u0026#34;accounts.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: for account in accounts: f.write(f\u0026#34;{account.mobile},{account.password}\\n\u0026#34;) def load_accounts(): accounts = [] if os.path.exists(\u0026#34;accounts.txt\u0026#34;): with open(\u0026#34;accounts.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: for line in f: mobile, password = line.strip().split(\u0026#39;,\u0026#39;) accounts.append(yiban(mobile, password)) return accounts def display_accounts(accounts): print(\u0026#34;当前账户列表:\u0026#34;) for idx, account in enumerate(accounts, start=1): print(f\u0026#34;{idx}. {account.mobile}\u0026#34;) def main(): accounts, disturb_mode, disturb_count = load_accounts() if disturb_mode == \u0026#39;on\u0026#39; and disturb_count \u0026gt; 0: print(\u0026#34;免打扰模式开启，自动执行...\u0026#34;) disturb_count -= 1 else: action = \u0026#39;继续\u0026#39; while action.lower() == \u0026#39;继续\u0026#39;: display_accounts(accounts) choice = input(\u0026#34;要修改或增加账号吗？(修改/增加/执行): \u0026#34;) if choice.lower() == \u0026#39;修改\u0026#39;: index = int(input(\u0026#34;请输入要修改的账号序号: \u0026#34;)) - 1 if 0 \u0026lt;= index \u0026lt; len(accounts): new_mobile = input(\u0026#34;输入新的手机号: \u0026#34;) new_password = input(\u0026#34;输入新的密码: \u0026#34;) accounts[index] = yiban(new_mobile, new_password) save_accounts(accounts, disturb_mode, disturb_count) print(\u0026#34;账户已更新\u0026#34;) elif choice.lower() == \u0026#39;增加\u0026#39;: num_new_accounts = int(input(\u0026#34;请输入要增加的账户数: \u0026#34;)) for _ in range(num_new_accounts): mobile = input(\u0026#34;请输入新手机号: \u0026#34;) password = input(\u0026#34;请输入新密码: \u0026#34;) accounts.append(yiban(mobile, password)) save_accounts(accounts, disturb_mode, disturb_count) print(\u0026#34;新账户已添加\u0026#34;) elif choice.lower() == \u0026#39;执行\u0026#39;: break action = input(\u0026#34;是否继续修改或增加账户？(继续/执行): \u0026#34;) if disturb_count == 0: # 当不在免打扰模式或免打扰次数用完时询问 disturb_mode = \u0026#39;on\u0026#39; if input(\u0026#34;是否开启免打扰模式？(是/否): \u0026#34;).lower() == \u0026#39;是\u0026#39; else \u0026#39;off\u0026#39; disturb_count = 7 if disturb_mode == \u0026#39;on\u0026#39; else 0 save_accounts(accounts, disturb_mode, disturb_count) for account in accounts: account.loginin() time.sleep(0.5) print(\u0026#34;#签到检查通过#################\\n\u0026#34;) for account in accounts: account.setall() time.sleep(0.1) print(\u0026#34;##############################\u0026#34;) print(\u0026#34;签到任务已执行完成！\u0026#34;) sys.exit() if __name__ == \u0026#34;__main__\u0026#34;: main() 一点点小改动 这个脚本有几处在Arch Linux上并不适用。\npip会往系统里面带脏东西，所以并不能直接执行pip install。会有如下报错：\npip install numpy error: externally-managed-environment × This environment is externally managed ╰─\u0026gt; To install Python packages system-wide, try \u0026#39;pacman -S python-xyz\u0026#39;, where xyz is the package you are trying to install. If you wish to install a non-Arch-packaged Python package, create a virtual environment using \u0026#39;python -m venv path/to/venv\u0026#39;. Then use path/to/venv/bin/python and path/to/venv/bin/pip. If you wish to install a non-Arch packaged Python application, it may be easiest to use \u0026#39;pipx install xyz\u0026#39;, which will manage a virtual environment for you. Make sure you have python-pipx installed via pacman. note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages. hint: See PEP 668 for the detailed specification. 最恰当的方法应该是给他来个虚拟环境。且msvcrt是一个Windows特定的模块，在Linux上不可用，可以代码里面直接给它扬了：\n...# 上述代码照抄 def loginin(self): # 登陆校验 # 应当先判断列表账号是否都能正常登陆 loginin = self.login() # 登录 if loginin != 1: print(\u0026#34;用户\u0026#34;,loginin,\u0026#34;登陆失败，请处理\u0026#34;) print(\u0026#34;按任意键退出脚本\u0026#34;)# 移除了msvcrt.getch()，因为在Linux上不可用 input(\u0026#34;按回车键退出脚本\u0026#34;) sys.exit() self.authorization(0) # 校本化授权先执行 return ...# 下面照抄 构建虚拟环境需要：\npython3 -m venv /path/to/new/virtual/environment source /path/to/new/virtual/environment/bin/activate pip install requests numpy jsonpath deactivate 在你的py文件目录下创建一个.sh：\n#!/bin/bash VENV_DIR=\u0026#34;/path/to/your/venv\u0026#34; SCRIPT_PATH=\u0026#34;/path/to/your/script.py\u0026#34; source \u0026#34;$VENV_DIR/bin/activate\u0026#34; python \u0026#34;$SCRIPT_PATH\u0026#34; deactivate chmod +x /path/to/your/script.sh /path/to/your/script.sh 然后就是考虑在Linux上如何进行定时任务的问题，经某位lockey朋友启发选择直接上大家所熟悉的cron：\nsudo pacman -S cronie sudo systemctl start cronie.service sudo systemctl enable cronie.service crontab -e # 转入nano编辑 0 0 * * * /path/to/your/script.sh # 自行照格式修改 #ctrl+o写入，enter，ctrl+x退出 crontab -l # 检查一下有没有写好 DONE.\n","permalink":"https://blog.nanimonai.org/posts/tech/research-on-the-principle-of-automatic-punch-in/","summary":"\u003ch1 id=\"这是什么\"\u003e这是什么\u003c/h1\u003e\n\u003cp\u003e近日，打卡更新方式，由之前转移到了某一新平台上。求知欲驱使进行研究。写的不周，还请包含，同时我要非常感谢lockey中的一位热心朋友不厌其烦地为我指点迷津。\u003c/p\u003e\n\u003ch1 id=\"如何实现\"\u003e如何实现\u003c/h1\u003e\n\u003ch2 id=\"第一步\"\u003e第一步\u003c/h2\u003e\n\u003cp\u003e首先是获取签到的数据。\u003c/p\u003e\n\u003cp\u003e先去官网下载.apk文件，而众所周知，.apk是一种压缩文件，所以直接解压出来，查找一下发现是rsa，然后思考如何拿到公钥。\n\u003cimg loading=\"lazy\" src=\"https://img.nanimonai.org/bunan.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e继续find寻找.pem，找到一个证书（本人搞到这里有点绷不住了，真的难绷）\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://img.nanimonai.org/pem.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e写如下代码以还原出公钥：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eimport OpenSSL.crypto\n\ncert_text = \u0026#34;\u0026#34;\u0026#34;\n-----BEGIN CERTIFICATE-----\nMIIFizCCA3OgAwIBAgIDAJY4MA0GCSqGSIb3DQEBCwUAMIGAMQswCQYDVQQGEwJD\nTjEQMA4GA1UECAwHQmVpamluZzEMMAoGA1UECgwDTVNBMREwDwYDVQQLDAhPQUlE\nX1NESzEeMBwGA1UEAwwVY29tLmJ1bi5taWl0bWRpZC5zaWduMR4wHAYJKoZIhvcN\nAQkBFg9tc2FAY2FpY3QuYWMuY24wHhcNMjQwMTA3MTQ0ODU1WhcNMjUwMTA3MTQ0\nODU1WjB9MQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpamluZzEQMA4GA1UEBwwH\nQmVpamluZzEQMA4GA1UECgwHd2phY2tlcjEWMBQGA1UEAwwNY29tLnlpYmFuLmFw\ncDEgMB4GCSqGSIb3DQEJARYRd2FuZ2ppZTJAeWliYW4uY24wggIiMA0GCSqGSIb3\nDQEBAQUAA4ICDwAwggIKAoICAQCyGC9T3GW4BSsvnVNqb8+HlnjJAQvTPd7H13m1\nf945uUsUYYMaaZuICYjb4qefZUyQgyxBUTYfBOTpE7ccdcNoZgCp05RTng30zvkc\n4pjawJIkNeIC2NGlN7RquO4Ka/06LSuq5N+bfL78E0MwZAinoxSswf/yNY5R1LJ2\nb3I7BnW7rVSb7KbB0Q4z5KmuJ04hPVl7BtSdfVnvnRVTBDRm/cMgyupEl+CCGW8H\nUejzPHdHeHRK1rx7fuwQI+5jgMmDYRNXZD4AmJ0vClurQR5avN2xOuxB8HbtB+lQ\nitsNnQCvYY1Xp4s7FtfmT6JzDNQ//vRgXxYrOaVFfoY/ugrO+SfZtqej+mdKR3Kg\nOaAA75t8zcJfM6WGrbPJl3xHc2bhD4kGwRkTAcHJ7WQOIrWz85CPCfIoYh8nZlBl\nsCNamJJh6Pl2nAtmnfMtDuYZJo/2QK6J/KFtywsYIekU6fiRsJaaunBf5sD9Ixbv\nJcRRB+HRCsySKYEg8z7Xlh90fHimfUgT0Gt44/o+nzPh7Cq9Ay6dWtMxYFx78Z1e\npapOJdUNpZWIET8wQHriJmbJ18TlidGRAW85kW2ka2cr4u6Ed68JQa+nN+kbS0dD\neuvOBGOsiqqCy5aeA0oz88HRWWIga02PLTZbEs4PdYrNzHWCISjnk34KpwwxYJUn\n6Zpy1wIDAQABoxAwDjAMBgNVHRMBAf8EAjAAMA0GCSqGSIb3DQEBCwUAA4ICAQAk\no30meLI9Un/7KoUekSMhterJ6K11cHKAa+WQqqzp8If+gIhjsyYk7Wf1fgStvoNu\njILWSAfe2C2k74QrlVsUFXue2Ekc+eyDbUhwOi4rVju68/eu4HSpdIUbFQ7ZpivC\nadjw7qfN90sp6S+O/dDQ9SzUPBpjMQQ6ZvSTFv7TtZ1cjzOpcfogrDGyOe+mE5Rv\nxT3IaWFBcY2fe8lh+/7mJ27A5XgCka1LTZ2OFwI4d1gPWRhwi7R0p4rGhtmk2JJG\nviz1rPn8pBBeR5zcwHFuDAbL/1C9d6rZ5lajycrdPZzbcuFAzx7NPafiMsyMYwBK\n9oQDIjS5UmfMt+lMFk37yCesFqxq/DOIPm1Hz3N1t5RpcZuwIkCzXYhtOkCbu9SZ\nxKqxztpcA5ySf3DWH4TIxKGXxIlC5pr2F4HsmKDIAO/1O6HXI0Bo+s/3KsDS/IMV\nnlqKu1WUKUZJebjN/CL61ChfHjkmogslgTkQpJnGsWsix3v0nBFjpbOm/oXYYMJy\np+aMzppKaLx3mniXW/kimteNKu8EdeE7x/QeEIk5IUotfRPAeydVk9yqf+c4ClS9\nYwVFAqIDzbC3nLBBXb36WNOoG+MFwWkjKoPhtIoLysTN1gNuFYUlJ1JptoP0Pe0I\nk5FWnRRk1vKUktYUfMJE4PQg4sWxZhGkKrGU5zVLsg==\n-----END CERTIFICATE-----\n\u0026#34;\u0026#34;\u0026#34;\n\ncert=OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert_text)\n\npublic_key=OpenSSL.crypto.dump_publickey(OpenSSL.crypto.FILETYPE_PEM, cert.get_pubkey()).decode(\u0026#34;utf-8\u0026#34;)\n\nprint(public_key)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e得出公钥就够用了：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://img.nanimonai.org/rsa.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"第二步\"\u003e第二步\u003c/h2\u003e\n\u003cp\u003e获取cookie，参考github可得：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\ndef auth(self):\n    COOKIES = {}\n    CSRF = \u0026#34;00000000000000000000000000000000\u0026#34;\n    HEADERS = {\n        \u0026#34;Origin\u0026#34;: \u0026#34;m.yiban.cn\u0026#34;,\n        \u0026#34;origin\u0026#34;:\u0026#34;api.uyiban.com\u0026#34;,\n        \u0026#34;origin\u0026#34;:\u0026#34;https://c.uyiban.com\u0026#34;,\n        \u0026#34;authority\u0026#34;: \u0026#34;api.uyiban.com\u0026#34;,\n        \u0026#34;AppVersion\u0026#34;: \u0026#34;5.0.17\u0026#34;,\n        \u0026#34;x-requested-with\u0026#34;: \u0026#34;com.yiban.app\u0026#34;,\n        \u0026#34;user-agent\u0026#34;:\u0026#34;Mozilla/5.0 (Linux; Android 12; XIAOMI Build/SKQ1.211006.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/112.0.5615.48 Mobile Safari/537.36;webank/h5face;webank/1.0 yiban_android/5.0.17\u0026#34;\n        }\n    iapp = requests.get(\u0026#34;http://f.yiban.cn/iapp/index?act=iapp7463\u0026#34;, headers=HEADERS, allow_redirects=False, cookies=COOKIES) # 利用 loginToken 访问获取 verifyRequest跳转数据\n    # 此处cookie带有 \u0026#34;loginToken\u0026#34; = “cdd6d4432743414c9e1faf3e792*****”\n    act = iapp.headers[\u0026#34;Location\u0026#34;] # 返回302跳转目标\n    verifyRequest = re.findall(r\u0026#34;verify_request=(.*?)\u0026amp;\u0026#34;, act)[0] # 正则取302跳转目标，得到 verify_request 数据\n    json = requests.get(\u0026#34;https://api.uyiban.com/base/c/auth/yiban?verifyRequest=\u0026#34; + verifyRequest + \u0026#34;\u0026amp;CSRF=\u0026#34; + CSRF, headers=HEADERS, allow_redirects=False, cookies={\u0026#39;csrf_token\u0026#39;: CSRF})\n    cookies = requests.utils.dict_from_cookiejar(json.cookies) # 获取cookie\n    Attendancecookies = cookies # 签到cookies赋值self.Attendancecookies\n    print(\u0026#39;Location:\u0026#39;,act,\u0026#34;\\n\u0026#34;)\n    print(\u0026#39;cookies:\u0026#39;,Attendancecookies,\u0026#34;\\n\u0026#34;)\n    \n    ###打印数据：\n    Location: https://c.uyiban.com/#/?verify_request=c9e814****53de92ccc\u0026#39;, \u0026#39;cpi\u0026#39;: \u0026#39;eyJD******%3D%3D\u0026#39;, \u0026#39;is_certified\u0026#39;: \u0026#39;1\u0026#39;}    \n    cookies: {\u0026#39;PHPSESSID\u0026#39;: \u0026#39;fa1a28bc38cc**c4b1e87a8ce51f****\u0026#39;, \u0026#39;cpi\u0026#39;: \u0026#39;eyJDaG**%3D%3D\u0026#39;, \u0026#39;is_certified\u0026#39;: \u0026#39;1\u0026#39;}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAll right. 现在只需要PHPSESSID.\u003c/p\u003e","title":"Research on the principle of automatic punch-in"},{"content":"这是什么 2024校EEA举办无人车的循迹避障赛。欣然规往。\n为什么去做这个 兴趣啊，混蛋！难道还是为了什么生计什么未来什么饭碗而去的嘛？\n咋做的 刚开始和队友是有甚大的意淫的，企图先整个初号机出来，选方案就选了挺久，然后参考了很多用nano主控，车架也是上便宜的亚克力，循迹依靠pwm调值，随便整个五路红外循迹接个面包板在来三节电池代码写写就完事。二代机直接上PID然后再优化机械结构，换更好电机之类的。\n事实上发现，这调试的东西也太多了。问题很多，情况非常多，是一开始所预想不到的。实现代码逻辑就得有不同的思路，前期兴致勃勃到，后期就是坚持就是成功，代码从开始的立志优化到最完美，到后来的能跑就行，一优化就又g了。不停的测试和排查故障是会令人烦躁的，例如：我误读要求以为要循迹两圈，然后抓耳挠腮写检测逻辑，最后基于队友原来代码写的是：\nvoid loop() { if(digitalRead(Button) == 0){ if (i \u0026lt; 5){ if(distance \u0026gt;25){ delay(10); xunxian(); } else{ bizhang(); } } else{ Motor(0, 0); } } else{ Motor(0,0); } } ... xunxian() ... else if (SL2 == 0 \u0026amp;\u0026amp; SL1 == 0 \u0026amp;\u0026amp; SR1 == 0 \u0026amp;\u0026amp; SR2 == 0 \u0026amp;\u0026amp; (SR3 == 0 || SL3 == 0)) { Motor(108+v,118+v); delay(10); i++; } ... 这样一坨我也不知道怎么形容的构思，直接给队友后面调车造成很大的困扰，虽然最后发现是电池电快无了，导致循迹都出现问题带不动电机转向。\n尝试过五路红外和光电之后都不行，那个b传感器不稳定于是乎就有一堆的误判，然后就谜之操作。后来直接上了六路灰度直接爽飞，进入下一个阶段的debug。 其实，笔者觉得不管是竞赛还是折腾东西，就是一个盛大的debug过程。世界就是一个巨大的草台班子。长期的游戏让我练就了被队友嬉笑怒骂不形于色的本领，我可以保证不首先使用言语攻击假想敌的家人，也保证不第一个给队友上压力。其次菜了得承认。最后，要有一颗折腾的心，这方面可能EOS教会我的更多一些，遇见不同种类，不同方式的问题刁难，有一些是很值得记录下来的，我以后也一定趁着自己还清醒要写文章记录一下。\n这样看下来，折腾的那些便不足为奇了，本就是一直折腾的青春，我倒是不介意多学点多折腾点东西。最后是一拍脑袋想起来我还有电池，刚好能完赛没犯病。看下比赛可以看到很多还值得学的东西，pwm调速是肯定比不上pid的，然后机械结构的优化，比如某大跌在现场指出可以把传感器架设在中间，会有利于车的性能提升。可以参考到很多组不同的实现思路，这个比赛本身的意义就已经彰显，大学缺乏思维的相互碰撞和激发，当然大多数人是不经意间的，教会你东西的可能是一个话都讲不上几句的类陌生人。\n然后我在反思，如果我失败了，一如我之前的些奇奇怪怪bug，有的时候tty都进不去，社区的方案也都尝试过了。失败了，我还会记录这些吗。答案很有可能是否，我会去自恃自己的记忆，而永远去逃避问题不了解其内容，也就是自身的进步仍然是基于一种脆弱的优越者假想甚至是自负论。还是不在tech里讨论自由意志和个人发展的孰优孰劣，多学多做就好。\n（完篇的时候，时钟正好停在自己的十九岁生日的最后一分钟，很奇妙的体验，自己已经立下决心将所有节日以平常心看待，看淡生活的种种波澜，也不相信知天命的话术，但仍会下意识有所注意，感慨小时候那个一到生日就期盼着别人祝福的单纯的我，已经过去这么久了啊。静静地等待这一分钟流逝过去。经历自己变老真的是一件奇妙的事情啊，不过我也无悔去肆意地挥霍我的青春。）\nDONE.\n","permalink":"https://blog.nanimonai.org/posts/tech/smart-car---freshman-trash-version/","summary":"\u003ch1 id=\"这是什么\"\u003e这是什么\u003c/h1\u003e\n\u003cp\u003e2024校EEA举办无人车的循迹避障赛。欣然规往。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://img.nanimonai.org/map.jpg\" alt=\"Map.\"  /\u003e\n\u003c/p\u003e\n\u003ch1 id=\"为什么去做这个\"\u003e为什么去做这个\u003c/h1\u003e\n\u003cp\u003e兴趣啊，混蛋！难道还是为了什么生计什么未来什么饭碗而去的嘛？\u003c/p\u003e\n\u003ch1 id=\"咋做的\"\u003e咋做的\u003c/h1\u003e\n\u003cp\u003e刚开始和队友是有甚大的意淫的，企图先整个初号机出来，选方案就选了挺久，然后参考了很多用nano主控，车架也是上便宜的亚克力，循迹依靠pwm调值，随便整个五路红外循迹接个面包板在来三节电池代码写写就完事。二代机直接上PID然后再优化机械结构，换更好电机之类的。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://img.nanimonai.org/choulou.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e事实上发现，这调试的东西也太多了。问题很多，情况非常多，是一开始所预想不到的。实现代码逻辑就得有不同的思路，前期兴致勃勃到，后期就是坚持就是成功，代码从开始的立志优化到最完美，到后来的能跑就行，一优化就又g了。不停的测试和排查故障是会令人烦躁的，例如：我误读要求以为要循迹两圈，然后抓耳挠腮写检测逻辑，最后基于队友原来代码写的是：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evoid loop() {\n  if(digitalRead(Button) == 0){\n    if (i \u0026lt; 5){\n      if(distance \u0026gt;25){\n        delay(10);\n        xunxian();\n      }\n      else{\n        bizhang();\n      }\n    }\n    else{\n      Motor(0, 0);\n    }\n  }\n  else{\n    Motor(0,0);\n  }\n}\n\n...\nxunxian()\n...\nelse if (SL2 == 0 \u0026amp;\u0026amp; SL1 == 0 \u0026amp;\u0026amp; SR1 == 0 \u0026amp;\u0026amp; SR2 == 0 \u0026amp;\u0026amp; (SR3 == 0 || SL3 == 0)) {\n    Motor(108+v,118+v);\n    delay(10);\n    i++;\n  }\n...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这样一坨我也不知道怎么形容的构思，直接给队友后面调车造成很大的困扰，虽然最后发现是电池电快无了，导致循迹都出现问题带不动电机转向。\u003c/p\u003e","title":"Smart car - freshman trash version"},{"content":"为什么研究这个 学校在企业微信里面要求所有大学生在21:30-23:00期间进行打卡操作。鉴于企业微信的位置获取不是一般的抽象，除了查看你的GPS信号外还有调用附近的基站进行定位（西瓜和Mike 语），最为逆天的是本人的移动设备是哄蒙系统，也就无法享用诸多先进科技带来的便利。\n因此，第一种方法应运而生：\n在手机上安装VMOS Pro，走虚拟机路线。其中的root和Xposed的模块安装均为傻瓜式操作，这里不过多赘述。BTW，虚拟安卓机在大学的另一大用途就是通过学习通考试。\n安装应用变量，Fake location（fuck location的开发者在安卓10上测试过，但是VMOS Pro版本只有7.1和9，有兴趣者可以尝试一下能否可行），而且我们需要的是具有基站模拟功能的位置模拟软件。在当前诈骗猖獗的情况下自建伪基站是不切实且无异于找死的。Fake location需要爆米，我记得7r/月。\nXposed Installer后，激活应用变量，配置指定应用（如企业微信），其中比较重要的是你的安卓版本，IMEI和MEID这几个需要留意。如果你在之前的手机/母鸡上面打过卡了，这些就要原封不动的抄原来手机。反之则无所谓。\n启动fake location。位置选择到位后启动模拟，同时启动基站模拟。\nPS：此法是由Mike和大西瓜研究而出。此法也有助于不同大学的上课打卡机制（我所了解的其他大学的打卡机制不是很严格），上班族的上班打卡机制。以及Fake location的路线模拟，可以帮助有需要者进行跑步的模拟。（导入运动软件进行操作云云），网络上面很多大佬也讲过类似操作，本人这样帮过朋友，证明其可行性。就是画路线的时候别超出操场或者撞墙里面了，以免露馅。\n好日子的结束 在一次美美不请假而出游的日子中，我意外发现第一种方法失效了。其具体表现为：地图识别我在A地（GPS），也就是目标打卡地，但是我的伪装被企业微信识破，即它能准确定位到我的真实所在地B地。而这个方案是在2023.12之前都有效的，且亲自实验过的。目前失败原因不明，有思路者欢迎联系我一起探讨。\n后经排查原因无果后，高人OO指点采用第二种方法。\nOO指出可以使用备用机装企业微信然后写自动脚本完成打卡，并且自己实验成功。\n虽然说用的是老旧的备用机。但是仍然要注意自己的安全，隐私等。我最开始试验是在Hamibot上，Hamibot可以远程执行脚本，安全系数低。它算一个云端控制，理论上讲服务器后退可以看我手机的内容甚至控制，所以并不推荐这个平台。里面虽然有日志，但是服务器是外人的。开发文档里面有扫描文件，截屏，OCR获取信息。理论上能获取你手机的任何操作单仅限于显示时候，锁屏没有密码脚本的话，也是开不起来的。如果真要使用也建议是暂时使用几次，不需要使用的时候推荐关闭无障碍。\n鄙人的脚本跑在一个叫OpenAuto.js的开源软件上(Github)目前测试也是可行的，甚至优于Hamibot，因为其可以设置脚本的定时执行和循环执行，可以完成很多很多的其他操作而不用把这些内容加到脚本编写里面去。但还是要提供无障碍和一些权限，因此仍然建议找台备用机。\n设置无障碍，省电设置云云。\n撰写并运行脚本。\n脚本编写可以参考(Github)，他是写Hamibot上的脚本的，可以参考借鉴思路。\n以下是我的打卡脚本，网络上有人说快捷打卡失误率较高，鄙人倒是没遇到过所以直接选择快捷打卡。这样进企业微信就行了，不用去完善导航到打卡栏再点击打卡的操作。\n// 确保开启了Auto.js的无障碍服务 auto.waitFor(); // 唤醒并解锁设备（根据你的设备情况，这里可以自定义解锁逻辑） device.wakeUp(); let { height, width } = device let x = width / 2 let y1 = (height / 3) * 2 let y2 = height / 3 swipe(x, y1, x + 5, y2, 500) sleep(3000) toastLog(\u0026#39;启动企业微信,准备打卡\u0026#39;) // 启动企业微信 app.launchPackage(\u0026#34;com.tencent.wework\u0026#34;); //此时应该会自动完成打卡 // 结束脚本 exit(); DONE.\n","permalink":"https://blog.nanimonai.org/posts/tech/wecom-check-in-crack/","summary":"\u003ch1 id=\"为什么研究这个\"\u003e为什么研究这个\u003c/h1\u003e\n\u003cp\u003e学校在企业微信里面要求所有大学生在21:30-23:00期间进行打卡操作。鉴于企业微信的位置获取不是一般的抽象，除了查看你的GPS信号外还有调用附近的基站进行定位（西瓜和Mike 语），最为逆天的是本人的移动设备是哄蒙系统，也就无法享用诸多先进科技带来的便利。\u003c/p\u003e\n\u003cp\u003e因此，第一种方法应运而生：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e在手机上安装VMOS Pro，走虚拟机路线。其中的root和Xposed的模块安装均为傻瓜式操作，这里不过多赘述。BTW，虚拟安卓机在大学的另一大用途就是通过学习通考试。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e安装应用变量，Fake location（fuck location的开发者在安卓10上测试过，但是VMOS Pro版本只有7.1和9，有兴趣者可以尝试一下能否可行），而且我们需要的是具有基站模拟功能的位置模拟软件。在当前诈骗猖獗的情况下自建伪基站是不切实且无异于找死的。Fake location需要爆米，我记得7r/月。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eXposed Installer后，激活应用变量，配置指定应用（如企业微信），其中比较重要的是你的安卓版本，IMEI和MEID这几个需要留意。如果你在之前的手机/母鸡上面打过卡了，这些就要原封不动的抄原来手机。反之则无所谓。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e启动fake location。位置选择到位后启动模拟，同时启动基站模拟。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003ePS：此法是由Mike和大西瓜研究而出。此法也有助于不同大学的上课打卡机制（我所了解的其他大学的打卡机制不是很严格），上班族的上班打卡机制。以及Fake location的路线模拟，可以帮助有需要者进行跑步的模拟。（导入运动软件进行操作云云），网络上面很多大佬也讲过类似操作，本人这样帮过朋友，证明其可行性。就是画路线的时候别超出操场或者撞墙里面了，以免露馅。\u003c/p\u003e\n\u003ch1 id=\"好日子的结束\"\u003e好日子的结束\u003c/h1\u003e\n\u003cp\u003e在一次美美不请假而出游的日子中，我意外发现第一种方法失效了。其具体表现为：地图识别我在A地（GPS），也就是目标打卡地，但是我的伪装被企业微信识破，即它能准确定位到我的真实所在地B地。而这个方案是在2023.12之前都有效的，且亲自实验过的。目前失败原因不明，有思路者欢迎联系我一起探讨。\u003c/p\u003e\n\u003cp\u003e后经排查原因无果后，高人OO指点采用第二种方法。\u003c/p\u003e\n\u003cp\u003eOO指出可以使用备用机装企业微信然后写自动脚本完成打卡，并且自己实验成功。\u003c/p\u003e\n\u003cp\u003e虽然说用的是老旧的备用机。但是仍然要注意自己的安全，隐私等。我最开始试验是在Hamibot上，Hamibot可以远程执行脚本，安全系数低。它算一个云端控制，理论上讲服务器后退可以看我手机的内容甚至控制，所以并不推荐这个平台。里面虽然有日志，但是服务器是外人的。开发文档里面有扫描文件，截屏，OCR获取信息。理论上能获取你手机的任何操作单仅限于显示时候，锁屏没有密码脚本的话，也是开不起来的。如果真要使用也建议是暂时使用几次，不需要使用的时候推荐关闭无障碍。\u003c/p\u003e\n\u003cp\u003e鄙人的脚本跑在一个叫OpenAuto.js的开源软件上\u003ca href=\"https://github.com/openautojs/openautojs\"\u003e(Github)\u003c/a\u003e目前测试也是可行的，甚至优于Hamibot，因为其可以设置脚本的定时执行和循环执行，可以完成很多很多的其他操作而不用把这些内容加到脚本编写里面去。但还是要提供无障碍和一些权限，因此仍然建议找台备用机。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e设置无障碍，省电设置云云。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e撰写并运行脚本。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e脚本编写可以参考\u003ca href=\"https://github.com/hlsky1988/WeChatCheckingIn\"\u003e(Github)\u003c/a\u003e，他是写Hamibot上的脚本的，可以参考借鉴思路。\u003c/p\u003e\n\u003cp\u003e以下是我的打卡脚本，网络上有人说快捷打卡失误率较高，鄙人倒是没遇到过所以直接选择快捷打卡。这样进企业微信就行了，不用去完善导航到打卡栏再点击打卡的操作。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 确保开启了Auto.js的无障碍服务\nauto.waitFor();\n\n// 唤醒并解锁设备（根据你的设备情况，这里可以自定义解锁逻辑）\ndevice.wakeUp();\nlet { height, width } = device\nlet x = width / 2\nlet y1 = (height / 3) * 2\nlet y2 = height / 3\nswipe(x, y1, x + 5, y2, 500)\nsleep(3000)\ntoastLog(\u0026#39;启动企业微信,准备打卡\u0026#39;)\n\n\n// 启动企业微信\napp.launchPackage(\u0026#34;com.tencent.wework\u0026#34;);\n\n//此时应该会自动完成打卡\n\n// 结束脚本\nexit();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eDONE.\u003c/strong\u003e\u003c/p\u003e","title":"WeCom check-in crack"},{"content":" 现代的青年愈发得迷失了。我也一样。所谓沉默，沉默的大多数。所谓嘈杂。一位看客，或许会好过突如其来的死亡吧。害怕失去害怕未知，害怕自己会对现实抱有期望\n听起来好像可笑的很。在一个青春中畏手畏脚，不敢做出承诺，也不怎么负责任。几年后回头看看，那会是庆幸还是懊悔？老者们责备，嘲笑年轻人的爱情，认为其只是源于欣赏，源于心理上虚假的自我幻想。青年人却嘲讽老者的“迂”，自以为能为另一半负起责任，能够互相包容。\n好像都有些偏激。\n仔细省察下来，自己亦无资格评头论足，有时候很想写一本自传体小说（像《在路上》那样）写下虚妄且矛盾的青春。你此时的不如意又有多重要，又有多少意义呢？积累成的只有经验。呵！又是经验，世故的思想，不再的初心。\n一名茫然的探险者，是要深知真情流露之危险的。不妨带上一幅假笑的面具，默默收下“这个孩子/人性格真好/善良/听话”的类似夸耀。自己究竟是什么啊？我究竟又是怎样一个人？“面具戴得太久了，久而久之，就会粘在脸上，想要摘下来，除非伤筋动骨扒皮”\n朋友以异样之眼光审视我正进行之写作，好像见到了什么不可理喻的东西。这纯粹是我浪费时间吧，我们是高三啊。有时我也这么认为，但还是要写点什么。感受到的真正的悲伤，会源自心底，怎么会像分数的小挫折。所谓悲伤，是心中只能掩盖不能化开的吧\n所谓大苦难，所谓人生\n阅读摘录：亲戚或余悲，他人亦已歌。死去何所道，托体同山阿。\n中国人极善造神，造了再毁，毁了再造，乐此不疲。\n","permalink":"https://blog.nanimonai.org/posts/think/%E8%88%9E%E6%96%87%E5%BC%84%E5%A2%A8/","summary":"\u003cp\u003e  现代的青年愈发得迷失了。我也一样。所谓沉默，沉默的大多数。所谓嘈杂。一位看客，或许会好过突如其来的死亡吧。害怕失去害怕未知，害怕自己会对现实抱有期望\u003c/p\u003e\n\u003cp\u003e听起来好像可笑的很。在一个青春中畏手畏脚，不敢做出承诺，也不怎么负责任。几年后回头看看，那会是庆幸还是懊悔？老者们责备，嘲笑年轻人的爱情，认为其只是源于欣赏，源于心理上虚假的自我幻想。青年人却嘲讽老者的“迂”，自以为能为另一半负起责任，能够互相包容。\u003c/p\u003e\n\u003cp\u003e  好像都有些偏激。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e  仔细省察下来，自己亦无资格评头论足，有时候很想写一本自传体小说（像《在路上》那样）写下虚妄且矛盾的青春。你此时的不如意又有多重要，又有多少意义呢？积累成的只有经验。呵！又是经验，世故的思想，不再的初心。\u003c/p\u003e\n\u003cp\u003e  一名茫然的探险者，是要深知真情流露之危险的。不妨带上一幅假笑的面具，默默收下“这个孩子/人性格真好/善良/听话”的类似夸耀。自己究竟是什么啊？我究竟又是怎样一个人？“面具戴得太久了，久而久之，就会粘在脸上，想要摘下来，除非伤筋动骨扒皮”\u003c/p\u003e\n\u003cp\u003e  朋友以异样之眼光审视我正进行之写作，好像见到了什么不可理喻的东西。这纯粹是我浪费时间吧，我们是高三啊。有时我也这么认为，但还是要写点什么。感受到的真正的悲伤，会源自心底，怎么会像分数的小挫折。所谓悲伤，是心中只能掩盖不能化开的吧\u003c/p\u003e\n\u003cp\u003e  所谓大苦难，所谓人生\u003c/p\u003e\n\u003cp\u003e  阅读摘录：亲戚或余悲，他人亦已歌。死去何所道，托体同山阿。\u003c/p\u003e\n\u003cp\u003e  中国人极善造神，造了再毁，毁了再造，乐此不疲。\u003c/p\u003e","title":"舞文弄墨"},{"content":" 找回了我用于记录往事的笔记本，近来手头的书也都还没读完，就权且写一些旧东西吧。\n2023.5 思想总是跑在前面。他看得太远，比只能活在当下的身体还远得多。拿掉希望就是让思想重新回归身体，而且身体总有一天会腐烂。\n2023.10 \u0026hellip;\n我在散落的书堆间坐下，多少次反复关注父亲不安的的神态和言辞。那时候我又听到蝉鸣。那声音与前阵子所闻不同，已是寒蝉之鸣。我在夏天回到故乡，呆坐在沸腾似的蝉鸣之中，屡屡生出莫名的悲哀。我感觉我的哀愁总是同这蝉噪一起渗入心底。当此之时，我总是一动不动地独自凝视着自己。\n我的哀愁在今夏归省后逐渐变换了情调。正如蝉声从蝉鸣变成寒蝉一般，我觉得周遭之人的命运也仿佛在巨大的轮回中渐次变动\n\u0026hellip;\n———夏目漱石《心》\n回忆 我有写日记的习惯是初中伊始的，一位对我有非常大影响的语文老师建议我每天写一点文字，不管是记录或是描写，对写作是很有帮助的。\n我听从了，原先觉得写无可写，是一件挺烦人的事情。比起自己发牢骚，我更喜欢看别人发，也就是看书。不知怎的，书越看约多，人也越来越愚钝，想得东西也越来越多，脑子里充斥着声音。那就都写着吧。\n看得东西可能多了一点，自己也变得奇怪起来了，没有以前那种乐观与兴奋感了。感受最深刻的就是共鸣，我现实经历的事情在书中出现，或者是书中的事情投射到现实。震惊之余也只好长出一口气，鼓起勇气面对明天。\n神性的解放，人性的回归。\n","permalink":"https://blog.nanimonai.org/posts/think/%E7%89%A2%E9%AA%9A/","summary":"\u003cp\u003e  找回了我用于记录往事的笔记本，近来手头的书也都还没读完，就权且写一些旧东西吧。\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"20235\"\u003e2023.5\u003c/h1\u003e\n\u003cp\u003e  思想总是跑在前面。他看得太远，比只能活在当下的身体还远得多。拿掉希望就是让思想重新回归身体，而且身体总有一天会腐烂。\u003c/p\u003e\n\u003ch1 id=\"202310\"\u003e2023.10\u003c/h1\u003e\n\u003cp\u003e  \u0026hellip;\u003cbr\u003e\n  我在散落的书堆间坐下，多少次反复关注父亲不安的的神态和言辞。那时候我又听到蝉鸣。那声音与前阵子所闻不同，已是寒蝉之鸣。我在夏天回到故乡，呆坐在沸腾似的蝉鸣之中，屡屡生出莫名的悲哀。我感觉我的哀愁总是同这蝉噪一起渗入心底。当此之时，我总是一动不动地独自凝视着自己。\u003c/p\u003e\n\u003cp\u003e  我的哀愁在今夏归省后逐渐变换了情调。正如蝉声从蝉鸣变成寒蝉一般，我觉得周遭之人的命运也仿佛在巨大的轮回中渐次变动\u003cbr\u003e\n  \u0026hellip;\u003c/p\u003e\n\u003cp\u003e———夏目漱石《心》\u003c/p\u003e\n\u003ch1 id=\"回忆\"\u003e回忆\u003c/h1\u003e\n\u003cp\u003e  我有写日记的习惯是初中伊始的，一位对我有非常大影响的语文老师建议我每天写一点文字，不管是记录或是描写，对写作是很有帮助的。\u003c/p\u003e\n\u003cp\u003e  我听从了，原先觉得写无可写，是一件挺烦人的事情。比起自己发牢骚，我更喜欢看别人发，也就是看书。不知怎的，书越看约多，人也越来越愚钝，想得东西也越来越多，脑子里充斥着声音。那就都写着吧。\u003c/p\u003e\n\u003cp\u003e  看得东西可能多了一点，自己也变得奇怪起来了，没有以前那种乐观与兴奋感了。感受最深刻的就是共鸣，我现实经历的事情在书中出现，或者是书中的事情投射到现实。震惊之余也只好长出一口气，鼓起勇气面对明天。\u003c/p\u003e\n\u003cp\u003e  神性的解放，人性的回归。\u003c/p\u003e","title":"牢骚"},{"content":"Hello,world!\n写下这些字时，我是一名迷茫的电脑小白，进入浩如烟海的赛博世界，越是走到深处越会觉得自己无知，觉得自己无从下手。\n先写些无用漂亮话吧：\n2023.7.20\n看到的，全是更悲惨的戏文，更绝望的独白，更无助的祈求，更冷漠的看客\n————《鲁镇社戏》 2023.8.21\n解构是一把双刃剑\n它能把所有顽固的糟粕变成乐子\n也能把一切崇高的理想化作虚无 ","permalink":"https://blog.nanimonai.org/posts/think/blog-test/","summary":"\u003cp\u003e\u003cstrong\u003eHello,world!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e写下这些字时，我是一名迷茫的电脑小白，进入浩如烟海的赛博世界，越是走到深处越会觉得自己无知，觉得自己无从下手。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e先写些无用漂亮话吧：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch2 id=\"鲁镇社戏\"\u003e2023.7.20\u003cbr\u003e\n看到的，全是更悲惨的戏文，更绝望的独白，更无助的祈求，更冷漠的看客\u003cbr\u003e\n————《鲁镇社戏》\u003c/h2\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch2 id=\"也能把一切崇高的理想化作虚无\"\u003e2023.8.21\u003cbr\u003e\n解构是一把双刃剑\u003cbr\u003e\n它能把所有顽固的糟粕变成乐子\u003cbr\u003e\n也能把一切崇高的理想化作虚无\u003c/h2\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"Blog Test"},{"content":"","permalink":"https://blog.nanimonai.org/posts/tech/babyrsa/","summary":"","title":""},{"content":"","permalink":"https://blog.nanimonai.org/posts/tech/first-try-on-re/","summary":"","title":""},{"content":" Ice Year Il n’y a pas de hasard, il n’y a que des rendez-vous. Yon Zilch 来自彼岸，归于虚无。浮华人生，黄粱一梦。 春风少年兄 你在世纪大道东门 Dich 用电子罗盘，转赛博核桃，勘电磁风水，寻网络龙脉 milvoid Milvoid 什么也没有的主页 sdy_zjx 可爱的学姐 金毛犬 可爱的学妹 watermeko ","permalink":"https://blog.nanimonai.org/link/","summary":"link","title":"Link"},{"content":"我是一个爱打游戏的小屁孩，目前正在努力学习跟上大人们的步伐，却又畏惧于大人们世界的惊涛骇浪，可能是我还没有准备好去经受苦难。\n本项目由 Hugo 生成\n主题 Paper 由 adityatelange 开发\n","permalink":"https://blog.nanimonai.org/about/","summary":"\u003cp\u003e我是一个爱打游戏的小屁孩，目前正在努力学习跟上大人们的步伐，却又畏惧于大人们世界的惊涛骇浪，可能是我还没有准备好去经受苦难。\u003c/p\u003e\n\u003cp\u003e本项目由 \u003ca href=\"https://gohugo.io/\"\u003eHugo\u003c/a\u003e 生成\u003c/p\u003e\n\u003cp\u003e主题 \u003ca href=\"https://github.com/adityatelange/hugo-Paper\"\u003ePaper\u003c/a\u003e 由 \u003ca href=\"https://github.com/adityatelange\"\u003eadityatelange\u003c/a\u003e 开发\u003c/p\u003e","title":"关于"}]